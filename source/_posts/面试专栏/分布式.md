---
title: 分布式
date: 2021-01-05
categories:
    - 专栏
tags:
    - 分布式
---

#### 什么是分布式事务？

#### 怎么解决分布式事务？

* 两阶段提交方案 / XA方案

两阶段提交有一个事务管理器的概念，负责协调多个数据源的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok
,那么就正事提交事务，在各个数据库上执行操作，如果任何一个数据库回答不ok，那么就回滚事务

这种分布式事务方案，比较适合单块应用里面，跨多个数据库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低
绝对不适合高并发的场景。可以通过Spring + JTA来实现

* TCC方案 （Try + Confirm + Cancel）
  * Try阶段：这个阶段说的就是对各个服务的资源做检测以及对资源进行锁定或者预留
  * Confirm阶段： 这个阶段就是在各个服务中执行实际的操作
  * Cancel阶段： 如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功业务逻辑的回滚操作

除非你的系统对一致性要求非常高，是你系统中核心中的核心场景，并且最好各个业务的执行时间较短。比如常见的就是资金类的场景，那就可以用TCC方案。
自己编写大量的业务逻辑，自己判断一个事务中的各个环节是否ok，不ok就执行回滚代码

这种方案几乎很少人使用，因为这个事务回滚实际严重依赖于你写的代码来回滚和补偿，会造成补偿代码巨大，非常恶心

* 本地消息表
    1. A系统在自己本地一个事务里面操作，同时插入一条数据到消息表里面
    2. 接着A系统将这个消息发送到MQ中去
    3. B系统接收到消息之后，在一个事务里，往自己本地消息表里面插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了那么这个事务会回滚，这样保证消息不会重复处理
    4. B系统执行成功之后，就会更新自己本地消息表的状态，以及A系统消息表的状态
    5. 如果B系统处理失败了，那么就不会更新消息表的状态，那么此时A系统会定时扫描自己的消息表，如果有没有处理的消息，会再次发送到MQ中去，让B再次处理
    6. 这个方案保证了最终的一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止

这个方案说实话最大的问题在于严重依赖于数据库的消息表来管理事务，这就导致高并发的场景下有性能瓶颈。怎么拓展？所以一般很少使用

![分布式事务-本地消息表](/images/面试/分布式事务-本地消息表.png)

* 可靠消息最终一致性方案 (基于RacketMQ事务消息)
    1. A系统先发一个prepared消息到MQ,如果这个prepared消息发送失败，那么直接取消操作
    2. 如果这个消息发送成了，那么接着执行一个本地事务，如果成功就告诉MQ发送确认消息，如果失败就告诉MQ发送回滚消息
    3. 如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地事务
    4. MQ会自动定时轮询所有prepared消息回调你的接口，问你这个消息是不是本地事务处理失败了，所以没有发送确认消息？那是继续重试还是回滚？一般来说这里我们就可以查询下数据库，之前本地事务是否执行了，如果回滚了那么这里也回滚吧。
    这样可以避免本地事务执行成功了，确认消息发送失败
    5. 这个方案里，要是系统B的事务处理失败怎么办？重试，自动不断重试直到成功，如果实在是不行，那么就要针对重要的资金业务进行回滚。比如B系统本地回滚以后，想办法通知系统A也回滚；或者发送报警由人工来回滚或者补偿

这个还是比较合适的，目前国内互联网公司大都是这么玩的。要不你举用RocketMQ支持的

![分布式事务-可靠消息最终一致性](/images/面试/分布式事务-可靠消息最终一致性.png)

* 最大努力通知方案
    1. 系统A本地事务执行完之后，发送个消息到MQ中
    2. 这里会有一个专门消费MQ的最大努力通知服务，这个服务会消费MQ，然后写入数据库中记录下来或者放入一个内存队列中，接着调用系统B的接口
    3. 要是系统B执行成功就ok了；要是系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B。反复N次，最后还是不行就放弃

![分布式事务-最大努力通知](/images/面试/分布式事务-最大努力通知.png)

如果是一个资金严格要求决定不能出错的场景，你可以说你用的TCC方案，如果是一般的分布式场景，如订单插入之后要更新库存，库存数据没有资金那么敏感
可以用可靠消息最终一致性方案
> 注意：rocketMQ 3.2.6之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变

#### 如何设计一个高并发的系统架构？

1. 系统拆分
    * 将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多了数据库，也可以支持高并发
2. 缓存（高并发读 必须用）
    * 大部分的高并发请求，都是读多写少，所以完全可以数据库和缓存各写一份，然后读的时候大量走缓存redis，毕竟redis单机就可以支持几万的并发
3. MQ （高并发写 必须用）
    * 把大量的写请求灌入MQ中，后面系统慢慢消费慢慢写，控制在mysql的承受范围内就可以了
4. Elasticsearch （可以考虑用）
    * es 是分布式的，可以随便扩容，分布式天然就可以支持高并发，因为动不动就可以扩容机器来抗更高的并发。那么一些简单的查询、统计类的操作，可以用es来承载，特别是全文检索类的操作
5. 分库分表
    * 可能到最后数据库层面还是免不了抗高并发的要求。这样我们可以将数据库拆分为多个库，多个库来抗更高的并发；如果一个表的数据量过大，我们还可以将一个表拆分成多个表，每个表的数据量保持少一点，提高sql的性能
6. 读写分离
    * 如果说大部分请求必须要落库，且读多写少，我们可以搞主从架构，主库写入，从库读取。当流量太多的时候，还可以加更多的从库
