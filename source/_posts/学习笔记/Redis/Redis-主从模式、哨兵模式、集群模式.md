---
title: Redis 主从模式、哨兵模式、集群模式
date: 2020-11-19
categories:
	- 学习
tags:
    - redis
---

### 主从模式

主从模式主要是基于Redis的主从复制特性架构的通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。主要的特点如下：

* 主从模式下，当某一节点损坏时，因为其会将数据备份到其它Redis实例上，这样做在很大程度上可以恢复丢失的数据
* 主从模式下，可以保证负载均衡
* 主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力
* 从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下
从以上，我们不难看出Redis在主从模式下，必须保证主节点不会宕机，一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis将丧失写的能力

### 哨兵模式

哨兵模式是redis高可用的实现方式之一，使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。

#### 哨兵们是怎么感知整个系统中的所有节点(主节点/从节点/哨兵节点)的

1. 首先主节点的信息是配置在哨兵(Sentinel)的配置文件中
2. 哨兵节点会和配置的主节点建立起两条连接 命令连接 和 订阅连接
3. 哨兵会通过命令连接每10s发送一次INFO命令，通过INFO命令，主节点会返回自己的run_id和自己的从节点信息
4. 哨兵会对这些从节点也建立两条连 接命令连接 和 订阅连接
5. 哨兵通过命令连接向从节点发送INFO命令，获取到他的一些信息
    * run_id
    * role
    * 从服务器的复制偏移量 offset
    * 其他
6. 因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，命令连接和订阅连接
    * 通过命令连接向服务器的_sentinel:hello频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等
    * 通过订阅连接对服务器的_sentinel:hello频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到
    * 解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来
    * 向观察到的其他的哨兵节点建立命令连接----没有订阅连接

#### 主观下线

哨兵节点会每秒一次的频率向建立了命令连接的实例发送ping命令，如果在down-after-milliseconds毫秒内没有响应，包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为SRI_S_DOWN主观下线

#### 客观下线

当一个哨兵节点发现主节点处于主观下线的状态，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了，如果超过配置参数quorum个节点认为主观下线，则该哨兵节点就会将自己的维护的结构体中该主节点标记为SRI_O_DOWN客观下线

``` shell
询问命令 SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <run_id>
* ip/port   当前认为下线的主节点的ip和端口
* current_epoch     配置纪元
* run_id    标识仅用于询问是否下线，有值表示该哨兵节点希望对方将自己设置为leader(询问时用*，选举时用run_id)
```

#### leader选举

在认为主节点客观下线的情况下,哨兵节点节点间会发起一次选举，命令还是上面的命令SENTINEL is-master-down-by-addr \<ip> \<port> <current_epoch> <run_id>,只是run_id这次会将从节点的run_id带进去，希望接受者将该节点设置为主节点。如果超过半数以上的节点返回将该节点标记为leader的情况下，会由该leader对故障进行迁移

#### 故障迁移

1. 在从节点中挑选出新的主节点
    * 通讯正常
    * 优先级排序
    * 优先级相同则选择offset最大的
2. 从节点执行 SLAVEOF no one 命令，关闭复制功能，将该节点设置成新的主节点
3. 将其他的从节点设置成从新的主节点复制, SLAVEOF命令
4. 将旧的主节点变成新的从节点

### 集群模式

官方提供的分布式方案（槽指派、重新分片、故障转移）

#### 槽指派

redis集群可以被分为16384个槽，只有这些槽全被指派了处理的节点情况下，集群的状态才能是上线状态（ok）
操作redis集群的时候，将key作为参数，就可以计算出对应的处理槽上，所以存储等操作都应该在该槽对应的节点上。通过这种方式，可以完美的实现集群存储的水平拓展

``` shell
def slot_number(key):
  return CRC16(key) & 16383
//得到的结果就是槽的序号
```

#### 重新分片

#### 故障转移

##### 发现故障节点

1. 集群内的节点会向其他节点发送PING命令，检查是否在线
2. 如果未能在规定时间内做出PONG响应，则会把对应的节点标记为疑似下线
3. 集群中一半以上负责处理槽的主节点都将主节点X标记为疑似下线的话，那么这个主节点X就会被认为是已下线
4. 向集群广播主节点X已下线,大家收到消息后都会把自己维护的结构体里的主节点X标记为已下线

##### 从节点选举

1. 当从节点发现自己复制的主节点已下线了，会向集群里面广播一条消息，要求所有有投票权的节点给自己投票(所有负责处理槽的主节点都有投票权)
2. 主节点会向第一个给他发选举消息的从节点回复支持
3. 当支持数量超过N/2+1的情况下，该从节点当选新的主节点

##### 故障迁移

1. 新当选的从节点执行 SLAVEOF no one,修改成主节点
2. 新的主节点会撤销所有已下线的老的主节点的槽指派，指派给自己
3. 新的主节点向集群发送命令，通知其他节点自己已经变成主节点了，负责哪些槽指派
4. 新的主节点开始处理自己负责的槽的命令

### 集群模式和哨兵模式的区别

1. 哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控
2. 哨兵模式发起选举是选举一个leader哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移
