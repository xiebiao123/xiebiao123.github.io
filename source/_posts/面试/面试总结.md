---
title: 面试100问
date: 2019-09-10
categories:
    - 面试
tags:
    - 面试
---

### 面试基础

#### 单例模式

* 要点：
  * 只能有一个实例 (构造器私有化)
  * 自行的创建实例 (该类的静态变量来保存这个唯一的实例)
  * 向整个系统提供这个实例  (直接暴露（饿汉式） | 用静态变量的get方法获取（懒汉式）)

* 饿汉式：直接创建对象（类加载的时候创建对象）、不存在线程安全问题
  * 直接实例化  (简洁直观)
  * 枚举式  (最简洁)
  * 静态代码块饿汉式 (适合复杂实例化)

* 懒汉式：延迟创建对象
  * 线程不安全  （单线程）
  * 线程安全  （多线程）
  * 静态内部类形式  （多线程）
  * 静态内部类不会随着外部类的加载和初始化而初始化，需要单独的加载和初始化

#### 成员方法、静态方法、代码块、静态代码块、父子类构造方法的执行顺序 (类的初始化过程、实例的初始化过程、父子类)

* 类的初始化过程：
  * 一个类要创建实例需要先加载并初始化该类
    * main方法所在的类需要先加载和初始化
  * 一个子类要初始化需要先初始化父类
  * 一个类初始化就是执行 clinit() 方法
    * clinit() 方法由静态类变量显示赋值代码和静态代码块组成
    * 执行顺序是从上到下顺序执行
    * clinit() 只会执行一次
* 实例的初始化过程
  * 实例初始化就是执行 init() 方法
    * init() 方法可能重载有多个，有几个构造器就有几个 init() 方法
    * init() 方法由非静态实例变量显示赋值代码、非静态代码块和对应的构造器组成
    * 非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而对应构造器代码最后执行
    * 每次创建实例对象，调用对应的构造器，执行的就是对应的 init() 方法
    * init() 方法的首行是super()或者super（实参列表），即对应父类的 init() 方法
* 方法的重写(Override)
  * 重写的原理
    * 非静态方法默认前面都会有一个this,this在 init() 方法中表示当前对象
  * 那些方法不会被重写
    * final修饰的方法
    * 静态方法
    * private等子类不可见方法
  * 注意事项
    1. 方法重写时，必须存在继承关系
    2. 方法重写时，方法名和形式参数必须一致。
    3. 方法重写时，子类的权限修饰符需要大于或等于父类的权限修饰符。
    4. 方法重写时，子类的返回值类型必须小于或等于父类的返回值类型
    5. 方法重写时，子类的异常类型要小于等于父类的异常类型。
* 方法的重载(Overload)
  * 方法的名称

### Spring 常见问题

#### IOC 和 AOP

* **IOC(控制反转)** 是一种设计思想，将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。IOC容器是Spring用来实现IOC的载体，
IOC容器实际上就是一个Map(key, value)，Map中存放的是各种对象
* **AOP(面向切面编程)** 能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，
便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。使用AOP之后我们可以把一些通用功能抽象出来，
在需要用到的地方直接使用即可，这样可以大大简化代码量，提高了系统的扩展性

#### Spring AOP / AspectJ AOP 的区别

1. Spring AOP属于运行时增强，而AspectJ是编译时增强
2. Spring AOP基于代理，而AspectJ基于字节码操作
3. AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面
太多的话，最好选择AspectJ，它比SpringAOP快很多
