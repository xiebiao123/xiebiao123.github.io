---
title: dubbo
date: 2021-01-05
categories:
    - 专栏
tags:
    - dubbo
---

#### 为什么要把系统拆成分布式的？为啥要用dubbo？

* 可维护性低
* 耦合性高

#### dubbo的工作原理是啥？注册中心挂了可以继续通信吗？

* dubbo十层架构

![dubbo十层架构](/images/面试/dubbo十层架构.png)

* dubbo工作流程

![dubbo工作流程](/images/面试/dubbo工作流程.png)

#### dubbo支持哪些通信协议？哪些序列化？

* dubbo支持通讯协议
  * dubbo协议（默认）
    * 单一长连接，NIO异步通信，基于hessian作为序列化协议。适用的场景就是传输数据量很小（每次请求在100kb以内），但是并发很高
    * 为了支持高并发场景，一般是服务提供者就几台机器，但是服务消费者就有上百台，可能每天调用量达到上亿次！此时用长连接是最适合的，就是跟每个服务消费者维持一个长连接就可以，可能总共就100个连接。然后后面直接基于长连接NIO异步通信，可以支持高并发请求。否则上亿次请求每次都是短连接的话，服务提供者会扛不住。而且因为走的是单一长连接，所以传输数据量太大的话，会导致并发能力降低，所以一般建议是传输数据量很小，支持高并发访问
  * rmi协议
    * 走java二进制系列化，多个短连接，适合消费者和提供者数量差不多，适用于文件的传输，一般很少使用
  * hessian协议
    * 走hessian序列化协议，多个短连接，适合提供者数量比消费者数量还多，适合文件的传输，一般很少使用
  * http协议
    * 走json序列化
  * webservice
    * 走SOAP文本序列化
* dubbo支持序列化
  * hessian序列化（默认）
  * java二进制系列化
  * json序列化
  * SOAP文本序列化
  
#### dubbo负载均衡策略？

* random loadbalance (默认)
  * dubbo是随机调用实现负载均衡，可以对provider不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高
* roundrobin loadbalance
  * 这个就是均匀的将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些
* leastactive loadbalance
  * 这个就是自动感知一下，如果某个机器性能差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求
* consistanthash loadbalance
  * 一致性Hash算法，相同参数的请求一定分发到一个provider上去，provider挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会很大

#### dubbo集群容错策略？

* failover cluster模式（默认）
  * 失败自动切换，自动重试其他机器，常见于读操作
* failfast cluster模式
  * 一次调用失败就立即失败，常见于写操作
* failsafe cluster模式
  * 出现异常时忽略掉，常用于不重要的接口调用，比如记录日志
* failbackc cluster模式
  * 失败了后台自动记录请求，然后定时重发，比较适合于写消息队列
* forking cluster模式
  * 并行调用多个provider，只要有一个成功就立即返回

#### dubbo动态代理策略？

默认使用javassist动态字节码生成，创建代理类。但是可以通过spi拓展机制配置自己的动态策略

#### SPI是啥思想？ dubbo SPI机制是怎么玩的？

SPI (service provider interface),简单来说SPI就是你有个接口，现在这个接口有三个实现类，那么系统在运行的时候对这个接口到底选择
那个实现类？这就需要SPI，需要根据指定的配置或者默认的配置，去找到对应的实现类加载进去，然后用这个实现类的实例对象

比如说你要通过jar包的方式给某个接口提供实现，然后你就在自己的jar包的 MERA-INFO/service/目录下放一个跟接口同名的文件，里面
指定接口的实现类是自己jar包里面的某个类，当别人用了这个接口并且用了你的jar包，就会在运行的时候通过你的jar包的那个文件找到
这个接口的实现类。

dubbo也用了SPI的思想，不过没有用JDK的SPI机制，是自己实现的一套SPI，dubbo微内核，大量可插拔的组件就是通过SPI实现的

#### dubbo如何做服务治理、服务降级以及重试？

##### 服务治理

* 服务访问链路
  * 自动生成服务调用链路图
* 服务访问压力以及时长的统计
  * 自动统计各个接口和服务之间的调用次数以及访问延时，而且要分成两个级别
    * 接口粒度，就是每个服务的每个接口，每天被调用多少次，以及每个接口的调用耗时
    * 请求的完整链路，每天全链路走多少次，全链路的请求耗时
* 其他
  * 服务分层（避免循环依赖）
  * 调用链路失败监控和报警
  * 服务鉴权
  * 每个服务的可用性监控（接口调用成功率？几个9？）

##### 服务降级

基于mock

##### 接口重试

retries + timeout

#### 分布式系统如何保证接口的幂等性?

1. 对于每个请求必须有一个唯一的标识
    * 例如订单支付请求里面的订单id
2. 每次处理完请求之后，必须有一个记录标识这个请求处理过了
3. 每次接收到请求，需要先判断之前是否处理过

#### 分布式系统如何保证接口的顺序性？

![分布式系统顺序性](/images/面试/分布式系统顺序性.png)

#### 如何设计一个dubbo的rpc框架？

1. 首先需要一个注册中心，保留各个服务的信息，可以用zookeeper来做
2. 然后消费者需要去注册中心拿到服务提供者的信息，而且每个服务可能会存在于多台机器上
3. 接着你就该发起一次请求了，咋发起？当然是基于动态代理，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理
，然后这个代理会找到服务对应的机器地址
4. 然后找那个机器发送请求？肯定需要一个负载均衡的算法，比如最简单的可以随机轮询，hash分配
5. 找到机器以后就可以发送请求了，第一个问题咋发送？你可以说netty , nio方式；第二个问题发送啥数据格式？你可以说用hessian序列化协议
6. 服务提供者这边一样，需要针对自己的服务生成一个动态代理，监听某个网络端口的，然后代理你本地的服务代码。接收到请求的时候
就调用对应的服务代码
