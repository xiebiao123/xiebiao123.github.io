<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奔跑的蜗牛</title>
  
  <subtitle>做自己爱做的事，爱自己在做的事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiebiao123.github.io/"/>
  <updated>2022-08-12T08:16:54.402Z</updated>
  <id>https://xiebiao123.github.io/</id>
  
  <author>
    <name>奔跑的蜗牛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作流框架Camunda</title>
    <link href="https://xiebiao123.github.io/2022/08/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%A1%86%E6%9E%B6Camunda/"/>
    <id>https://xiebiao123.github.io/2022/08/10/学习笔记/其他/工作流框架Camunda/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-12T08:16:54.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h3><p><a href="https://zhuanlan.zhihu.com/p/435249026" target="_blank" rel="noopener">工作流框架对比</a></p><a id="more"></a><h3 id="SpringBoot-集成Camunda"><a href="#SpringBoot-集成Camunda" class="headerlink" title="SpringBoot 集成Camunda"></a>SpringBoot 集成Camunda</h3><ul><li>pom文件配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringBoot 2.2.0以上版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 流程引擎 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.camunda.bpm.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda-bpm-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web界面模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.camunda.bpm.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda-bpm-spring-boot-starter-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  rest服务接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.camunda.bpm.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda-bpm-spring-boot-starter-rest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yml文件配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">camunda-demo</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/camunda-demo?serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">camunda:</span></span><br><span class="line">  <span class="attr">bpm:</span></span><br><span class="line">    <span class="attr">admin-user:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">first-name:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">filter:</span></span><br><span class="line">      <span class="attr">create:</span> <span class="string">All</span> <span class="string">tasks</span></span><br><span class="line">    <span class="comment">#禁止自动部署resources下面的bpmn文件</span></span><br><span class="line">    <span class="attr">auto-deployment-enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><p>下载bpmn建模工具：<a href="https://camunda.com/download/modeler/" target="_blank" rel="noopener">https://camunda.com/download/modeler/</a></p></li><li><p>画一个流程图另存为 apply.bpmn</p></li><li><p>testDemo</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  RepositoryService repositoryService;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  RuntimeService runtimeService;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  TaskService taskService;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  HistoryService historyService;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  ProcessEngine processEngine;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  ProcessEngine engine;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/deploy"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Deployment deploy = repositoryService.createDeployment()</span><br><span class="line">        .addClasspathResource(<span class="string">"BPMN/apply.bpmn"</span>)</span><br><span class="line">        .deploy();</span><br><span class="line">    System.out.println(deploy.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/start"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runProcinst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    params.put(<span class="string">"money"</span>,<span class="number">2001</span>);</span><br><span class="line">    ProcessInstance apply = runtimeService.startProcessInstanceByKey(<span class="string">"apply"</span>,params);</span><br><span class="line">    System.out.println(apply.getProcessDefinitionId());</span><br><span class="line">    System.out.println(apply.getId());</span><br><span class="line">    System.out.println(apply.getProcessInstanceId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/taskquery"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Task&gt; tasks = taskService.createTaskQuery()</span><br><span class="line">        .processDefinitionKey(<span class="string">"apply"</span>)</span><br><span class="line">        .list();</span><br><span class="line">    <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">      System.out.println(task.getAssignee());</span><br><span class="line">      System.out.println(task.getId());</span><br><span class="line">      System.out.println(task.getName());</span><br><span class="line">      System.out.println(task.getTenantId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/mytaskquery"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;HistoricTaskInstance&gt; <span class="title">myTaskQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricTaskInstance&gt; instances = engine.getHistoryService().createHistoricTaskInstanceQuery()</span><br><span class="line">        .taskAssignee(<span class="string">"lisi"</span>).unfinished().orderByHistoricActivityInstanceStartTime().asc().list();</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/taskComplete"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskComplete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery()</span><br><span class="line">        .taskAssignee(<span class="string">"zhangsan"</span>)</span><br><span class="line">        .singleResult();</span><br><span class="line">    Map&lt;String,Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    params.put(<span class="string">"monge"</span>,<span class="string">"2000"</span>);</span><br><span class="line">    taskService.complete(task.getId(),params);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/queryDefine"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryDefine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery();</span><br><span class="line">    List&lt;ProcessDefinition&gt; definitions = query.processDefinitionKey(<span class="string">"apply"</span>)</span><br><span class="line">        .orderByProcessDefinitionVersion()</span><br><span class="line">        .desc()</span><br><span class="line">        .list();</span><br><span class="line">    <span class="keyword">for</span> (ProcessDefinition definition : definitions) &#123;</span><br><span class="line">      System.out.println(definition.getDeploymentId());</span><br><span class="line">      System.out.println(definition.getName());</span><br><span class="line">      System.out.println(definition.getVersion());</span><br><span class="line">      System.out.println(definition.getId());</span><br><span class="line">      System.out.println(definition.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/deleteDefine"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDefine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();</span><br><span class="line">    List&lt;ProcessDefinition&gt; definitions = processDefinitionQuery.processDefinitionKey(<span class="string">"apply"</span>)</span><br><span class="line">        .orderByProcessDefinitionVersion()</span><br><span class="line">        .asc()</span><br><span class="line">        .list();</span><br><span class="line">    ProcessDefinition processDefinition = definitions.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (processDefinition != <span class="keyword">null</span>)&#123;</span><br><span class="line">      repositoryService.deleteDeployment(processDefinition.getDeploymentId(),<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"/queryHistory"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryHistory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery()</span><br><span class="line">        .finished()</span><br><span class="line">        .orderByHistoricActivityInstanceEndTime()</span><br><span class="line">        .asc()</span><br><span class="line">        .list();</span><br><span class="line">    <span class="keyword">for</span> (HistoricActivityInstance instance : list) &#123;</span><br><span class="line">      System.out.println(instance.getActivityId());</span><br><span class="line">      System.out.println(instance.getProcessDefinitionKey());</span><br><span class="line">      System.out.println(instance.getAssignee());</span><br><span class="line">      System.out.println(instance.getStartTime());</span><br><span class="line">      System.out.println(instance.getEndTime());</span><br><span class="line">      System.out.println(<span class="string">"============================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcInstAddBusinessKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ProcessInstance apply = runtimeService.startProcessInstanceByKey(<span class="string">"apply"</span>, <span class="string">"aaaa-scsc-89uc"</span>);</span><br><span class="line">    System.out.println(apply.getBusinessKey());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;框架对比&quot;&gt;&lt;a href=&quot;#框架对比&quot; class=&quot;headerlink&quot; title=&quot;框架对比&quot;&gt;&lt;/a&gt;框架对比&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/435249026&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作流框架对比&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Camunda" scheme="https://xiebiao123.github.io/tags/Camunda/"/>
    
      <category term="工作流" scheme="https://xiebiao123.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Retry框架对 SpringRetry与GuavaRetry</title>
    <link href="https://xiebiao123.github.io/2022/08/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/retry%E6%A1%86%E6%9E%B6/"/>
    <id>https://xiebiao123.github.io/2022/08/10/学习笔记/其他/retry框架/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-25T15:01:36.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重试框架之SpringRetry"><a href="#重试框架之SpringRetry" class="headerlink" title="重试框架之SpringRetry"></a>重试框架之SpringRetry</h3><p>SpringRetry 为 Spring 应用程序提供了声明性重试支持。它用于Spring批处理、Spring集成、Apache Hadoop(等等)。它主要是针对可能抛出异常的一些调用操作，进行有策略的重试</p><a id="more"></a><h4 id="SpringRetry的普通使用方式"><a href="#SpringRetry的普通使用方式" class="headerlink" title="SpringRetry的普通使用方式"></a>SpringRetry的普通使用方式</h4><ul><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加任务方法,我这里是采用一个随机整数，根据不同的条件返回不同的值，或者抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryDemoTask</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重试方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">retryTask</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"收到请求参数:&#123;&#125;"</span>,param);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      i = SecureRandom.getInstanceStrong().nextInt(<span class="number">11</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RemoteAccessException(<span class="string">"获取随机数失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"随机生成的数:&#123;&#125;"</span>,i);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      log.info(<span class="string">"为0,抛出参数异常."</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数异常"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i  == <span class="number">1</span>)&#123;</span><br><span class="line">      log.info(<span class="string">"为1,返回true."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)&#123;</span><br><span class="line">      log.info(<span class="string">"为2,返回false."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//为其他</span></span><br><span class="line">        log.info(<span class="string">"大于2,抛出自定义异常."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteAccessException(<span class="string">"大于2,抛出远程访问异常"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用SpringRetryTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRetryTemplateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重试间隔时间ms,默认1000ms</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> fixedPeriodTime = <span class="number">1000L</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最大重试次数,默认为3</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRetryTimes = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表示哪些异常需要重试,key表示异常的字节码,value为true表示需要重试</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; exceptionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    exceptionMap.put(RemoteAccessException<span class="class">.<span class="keyword">class</span>,<span class="title">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建重试模板实例</span></span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试回退操作策略，主要设置重试间隔时间</span></span><br><span class="line">    FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">    backOffPolicy.setBackOffPeriod(fixedPeriodTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试策略，主要设置重试次数</span></span><br><span class="line">    SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(maxRetryTimes, exceptionMap);</span><br><span class="line"></span><br><span class="line">    retryTemplate.setRetryPolicy(retryPolicy);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line"></span><br><span class="line">    Boolean execute = retryTemplate.execute(</span><br><span class="line">            <span class="comment">//RetryCallback</span></span><br><span class="line">            retryContext -&gt; &#123;</span><br><span class="line">              <span class="keyword">boolean</span> b = RetryDemoTask.retryTask(<span class="string">"abc"</span>);</span><br><span class="line">              log.info(<span class="string">"调用的结果:&#123;&#125;"</span>, b);</span><br><span class="line">              <span class="keyword">return</span> b;</span><br><span class="line">            &#125;,</span><br><span class="line">            retryContext -&gt; &#123;</span><br><span class="line">              <span class="comment">//RecoveryCallback</span></span><br><span class="line">              log.info(<span class="string">"已达到最大重试次数或抛出了不重试的异常~~~"</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      );</span><br><span class="line">    log.info(<span class="string">"执行结果:&#123;&#125;"</span>,execute);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>retryTemplate 承担了重试执行者的角色，它可以设置SimpleRetryPolicy(重试策略，设置重试上限，重试的根源实体)，FixedBackOffPolicy（固定的回退策略，设置执行重试回退的时间间隔）。</p><p>RetryTemplate通过execute提交执行操作，需要准备RetryCallback 和RecoveryCallback 两个类实例，RetryCallback对应的就是重试回调逻辑实例，包装正常的功能操作，RecoveryCallback实现的是整个执行操作结束的恢复操作实例.只有在调用的时候抛出了异常，并且异常是在exceptionMap中配置的异常，才会执行重试操作，否则就调用到excute方法的第二个执行方法RecoveryCallback中。</p><p>当然,重试策略还有很多种,回退策略也是:</p><p><strong>重试策略</strong></p><ul><li><strong>NeverRetryPolicy：</strong>    只允许调用RetryCallback一次，不允许重试</li><li><strong>AlwaysRetryPolicy：</strong>   允许无限重试，直到成功，此方式逻辑不当会导致死循环</li><li><strong>SimpleRetryPolicy：</strong>   固定次数重试策略，默认重试最大次数为3次，<strong>RetryTemplate默认使用的策略</strong></li><li><strong>TimeoutRetryPolicy：</strong>  超时时间重试策略，默认超时时间为1秒，在指定的超时时间内允许重试</li><li><strong>ExceptionClassifierRetryPolicy：</strong>  设置不同异常的重试策略，类似组合重试策略，区别在于这里只区分不同异常的重试</li><li><strong>CircuitBreakerRetryPolicy：</strong> 有熔断功能的重试策略，需设置3个参数openTimeout、resetTimeout和delegate</li><li><strong>CompositeRetryPolicy：</strong>  组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许即可以重试，悲观组合重试策略是指只要有一个策略不允许即可以重试，但不管哪种组合方式，组合中的每一个策略都会执行</li></ul><p><strong>重试回退策略</strong>  重试回退策略，指的是每次重试是立即重试还是等待一段时间后重试。<strong>默认情况下是立即重试</strong>，如果需要配置等待一段时间后重试则需要指定回退策略BackoffRetryPolicy。</p><ul><li><strong>NoBackOffPolicy：</strong> 无退避算法策略，每次重试时立即重试</li><li><strong>FixedBackOffPolicy：</strong>  固定时间的退避策略，需设置参数sleeper和backOffPeriod，sleeper指定等待策略，默认是Thread.sleep，即线程休眠，backOffPeriod指定休眠时间，默认1秒</li><li><strong>UniformRandomBackOffPolicy：</strong>  随机时间退避策略，需设置sleeper、minBackOffPeriod和maxBackOffPeriod，该策略在minBackOffPeriod,maxBackOffPeriod之间取一个随机休眠时间，minBackOffPeriod默认500毫秒，maxBackOffPeriod默认1500毫秒</li><li><strong>ExponentialBackOffPolicy：</strong>  指数退避策略，需设置参数sleeper、initialInterval、maxInterval和multiplier，initialInterval指定初始休眠时间，默认100毫秒，maxInterval指定最大休眠时间，默认30秒，multiplier指定乘数，即下一次休眠时间为当前休眠时间*multiplier</li><li><strong>xponentialRandomBackOffPolicy：</strong>   随机指数退避策略，引入随机乘数可以实现随机乘数回退</li></ul><h4 id="SpringRetry的注解使用方式"><a href="#SpringRetry的注解使用方式" class="headerlink" title="SpringRetry的注解使用方式"></a>SpringRetry的注解使用方式</h4><ul><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在application启动类上加上@EnableRetry的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了方便测试，我这里写了一个SpringBootTest的测试基类，需要使用SpringBootTest的只要继承这个类就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= SpringRetryApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyBaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"----------------测试开始---------------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@After</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"----------------测试结束---------------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们只要在需要重试的方法上加@Retryable，在重试失败的回调方法上加@Recover，下面是这些注解的属性</p></li><li><p><strong>@EnableRetry</strong> 是否开启重试</p><ul><li>proxyTargetClass： 默认值false, 表示是否创建基于子类的cglib代理，而不是创建标准的基于的基于java接口的代理</li></ul></li><li><p><strong>@Retryable</strong> 标注此注解的方法会在发生异常时进行重试</p><ul><li>interceptor： 将interceptor的bean名称应用到retryable()</li><li>value: 可重试的异常类型</li><li>label: 统计报告的唯一标签</li><li>maxAttempts: 尝试的最大次数（包括第一次失败），默认为3次</li><li>backoff: @BackOff 指定用于重试次操作的backoff属性。默认为空<ul><li>delay: 重试等待，默认使用1000ms</li><li>maxDelay: 最大重试等待时间</li><li>multiplier: 延迟的乘数，用于计算下一个延迟（大于0生效）</li><li>random： 随机重试等待时间，默认false</li></ul></li></ul></li></ul><p>建立一个serviced类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRetryDemo</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 重试所调用方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Retryable</span>(value = &#123;RemoteAccessException<span class="class">.<span class="keyword">class</span>&#125;,<span class="title">maxAttempts</span> </span>= <span class="number">3</span>,backoff = <span class="meta">@Backoff</span>(delay = <span class="number">2000L</span>,multiplier = <span class="number">2</span>))</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">call</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> RetryDemoTask.retryTask(param);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 达到最大重试次数,或抛出了一个没有指定进行重试的异常</span></span><br><span class="line"><span class="comment">   * recover 机制</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e 异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Recover</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(Exception e,String param)</span> </span>&#123;</span><br><span class="line">    log.error(<span class="string">"达到最大重试次数,或抛出了一个没有指定进行重试的异常:"</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们调用这个service里面的call方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRetryDemoTest</span> <span class="keyword">extends</span> <span class="title">MyBaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> SpringRetryDemo springRetryDemo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> abc = springRetryDemo.call(<span class="string">"abc"</span>);</span><br><span class="line">    log.info(<span class="string">"--结果是:&#123;&#125;--"</span>,abc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里我依然是RemoteAccessException的异常才重试，@Backoff(delay = 2000L,multiplier = 2))表示第一次间隔2秒，以后都是次数的2倍,也就是第二次4秒，第三次6秒.</p><h3 id="重试框架之GuavaRetry"><a href="#重试框架之GuavaRetry" class="headerlink" title="重试框架之GuavaRetry"></a>重试框架之GuavaRetry</h3><p>GuavaRetry工具与SpringRetry类似，都是通过定义重试者角色来包装正常逻辑重试，但是Guava retry有更优的策略定义，在支持重试次数和重试频度控制基础上，能够兼容支持多个异常或者自定义实体对象的重试源定义，让重试功能有更多的灵活性。</p><p>GuavaRetry也是线程安全的，入口调用逻辑采用的是Java.util.concurrent.Callable的call方法，示例代码如下：</p><ul><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.rholder/guava-retrying --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.rholder<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava-retrying<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加测试任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaRetryDemoTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">retryTask</span><span class="params">(String param)</span>  </span>&#123;</span><br><span class="line">    log.info(<span class="string">"收到请求参数:&#123;&#125;"</span>,param);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      i = SecureRandom.getInstanceStrong().nextInt(<span class="number">11</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RemoteAccessException(<span class="string">"获取随机数失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"随机生成的数:&#123;&#125;"</span>,i);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      log.info(<span class="string">"为0,抛出参数异常."</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数异常"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i  &lt; <span class="number">5</span>)&#123;</span><br><span class="line">      log.info(<span class="string">"为1,返回true."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">7</span>)&#123;</span><br><span class="line">      log.info(<span class="string">"为2,返回false."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//为其他</span></span><br><span class="line">      log.info(<span class="string">"大于2,抛出自定义异常."</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RemoteAccessException(<span class="string">"大于2,抛出自定义异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GuavaRetry 这里设定跟SpringRetry不一样，我们可以根据返回的结果来判断是否重试，比如返回false我们就重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// RetryerBuilder 构建重试实例 retryer,可以设置重试源且可以支持多个重试源，可以配置重试次数或重试超时时间，以及可以配置等待时间间隔</span></span><br><span class="line">  Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt; newBuilder()</span><br><span class="line">      <span class="comment">//设置异常重试源</span></span><br><span class="line">          .retryIfExceptionOfType(RemoteAccessException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">      //设置根据结果重试</span></span><br><span class="line"><span class="class">          .<span class="title">retryIfResult</span>(<span class="title">res</span>-&gt; !<span class="title">res</span>)</span></span><br><span class="line"><span class="class">      //设置等待间隔时间</span></span><br><span class="line"><span class="class">          .<span class="title">withWaitStrategy</span>(<span class="title">WaitStrategies</span>.<span class="title">fixedWait</span>(3, <span class="title">TimeUnit</span>.<span class="title">SECONDS</span>))</span></span><br><span class="line"><span class="class">      //设置最大重试次数</span></span><br><span class="line"><span class="class">          .<span class="title">withStopStrategy</span>(<span class="title">StopStrategies</span>.<span class="title">stopAfterAttempt</span>(3))</span></span><br><span class="line"><span class="class">          .<span class="title">build</span>()</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    retryer.call(() -&gt; RetryDemoTask.retryTask(<span class="string">"abc"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们可以更灵活的配置重试策略，比如:</p><ul><li><strong>retryIfException:</strong> 抛出 runtime 异常、checked 异常时都会重试，但是抛出 error 不会重试。</li><li><strong>retryIfRuntimeException:</strong> 只会在抛 runtime 异常的时候才重试，checked 异常和error 都不重试。</li><li><strong>retryIfExceptionOfType:</strong> 允许我们只在发生特定异常的时候才重试，比如NullPointerException 和 IllegalStateException 都属于 runtime 异常，也包括自定义的error。</li><li><strong>retryIfResult:</strong> 可以指定你的 Callable 方法在返回值的时候进行重试</li><li><strong>RetryListener:</strong> 当发生重试之后，假如我们需要做一些额外的处理动作，比如log一下异常，那么可以使用RetryListener。每次重试之后，guava-retrying 会自动回调我们注册的监听。可以注册多个RetryListener，会按照注册顺序依次调用。</li></ul><p>主要的配置：</p><ul><li><strong>AttemptTimeLimiter：</strong> 单次任务执行时间限制，如果超过配置则终止执行当前任务</li><li><strong>BlockStrategy：</strong> 任务阻塞策略，通俗来讲就是当前任务执行完，下次任务还没开始这段时间做什么，默认策略BlockStrategies.THREAD_SLEEP_STRATEGY</li><li><strong>RetryListener：</strong> 自定义重试监听器</li><li><strong>StopStrategy：</strong> 重试停止策略<ul><li><strong>StopAfterDelayStrategy</strong> 设置一个最长允许的执行时间，比如设定最长执行10秒，无论任务执行次数，只要重试的时候超过了最长时间，则任务终止，并返回重试异常RetryException</li><li><strong>StopAfterAttemptStrategy</strong> 设置最大重试次数，如果超过最大重试次数则停止重试，并返回重试异常</li><li><strong>NeverStopStrategy</strong> 不停止，用于需要一直轮训直到返回期望结果的情况</li></ul></li><li><strong>WaitStrategy：</strong> 重试等待时长<ul><li><strong>FixedWaitStrategy</strong>         固定等待时长策略</li><li><strong>RandomWaitStrategy</strong>        随机等待时长策略（可以提供一个最小和最大时长，等待时长为其区间随机值）</li><li><strong>IncrementingWaitStrategy</strong>  递增等待时长策略（提供一个初始值和步长，等待时间随着重试次数增加而增加）</li><li><strong>ExponentialWaitStrategy</strong>   指数等待时长策略</li><li><strong>FibonacciWaitStrategy</strong>   斐波那契等待时长策略</li><li><strong>ExceptionWaitStrategy</strong>   异常时长等待策略</li><li><strong>CompositeWaitStrategy</strong>   复合时长等待策略</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SpringRetry 和 GuavaRetry 工具都是线程安全的重试，能够支持并发业务场景的重试逻辑正确性。两者都很好的将正常方法和重试方法进行了解耦，可以设置超时时间、重试次数、间隔时间、监听结果、都是不错的框架。</p><p>但是明显感觉得到，GuavaRetry在使用上更便捷，更灵活，能根据方法返回值来判断是否重试，而SpringRetry只能根据抛出的异常来进行重试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;重试框架之SpringRetry&quot;&gt;&lt;a href=&quot;#重试框架之SpringRetry&quot; class=&quot;headerlink&quot; title=&quot;重试框架之SpringRetry&quot;&gt;&lt;/a&gt;重试框架之SpringRetry&lt;/h3&gt;&lt;p&gt;SpringRetry 为 Spring 应用程序提供了声明性重试支持。它用于Spring批处理、Spring集成、Apache Hadoop(等等)。它主要是针对可能抛出异常的一些调用操作，进行有策略的重试&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringRetry" scheme="https://xiebiao123.github.io/tags/SpringRetry/"/>
    
      <category term="GuavaRetry" scheme="https://xiebiao123.github.io/tags/GuavaRetry/"/>
    
  </entry>
  
  <entry>
    <title>Redis 为什么比较快</title>
    <link href="https://xiebiao123.github.io/2022/08/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E8%BE%83%E5%BF%AB/"/>
    <id>https://xiebiao123.github.io/2022/08/09/学习笔记/中间件/Redis/Redis-为什么比较快/</id>
    <published>2022-08-08T16:00:00.000Z</published>
    <updated>2022-08-10T07:45:44.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis-中的查询速度为什么那么快呢？"><a href="#Redis-中的查询速度为什么那么快呢？" class="headerlink" title="Redis 中的查询速度为什么那么快呢？"></a>Redis 中的查询速度为什么那么快呢？</h3><ol><li>因为它是内存数据库</li><li>归功于它的数据结构（SDS简单动态字符串、链表、压缩列表、跳表、整数数组、哈希表）</li><li>Redis是单线程（6.0版本引入多线程，通过多线程的 IO 来处理网络请求，但是处理事件队列的命令是单线程的）</li><li>Redis中使用了多路复用</li></ol><a id="more"></a><h4 id="Redis-中的数据结构"><a href="#Redis-中的数据结构" class="headerlink" title="Redis 中的数据结构"></a>Redis 中的数据结构</h4><p><img src="/images/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.jpg" alt="redis数据类型与数据结构关系"></p><h5 id="1-简单动态字符串-SDS"><a href="#1-简单动态字符串-SDS" class="headerlink" title="1 简单动态字符串 SDS"></a>1 简单动态字符串 SDS</h5><p>Redis 中并没有使用 C 中 char 来表示字符串，而是引入了 简单动态字符串（Simple Dynamic Strings，SDS）来存储字符串和整型数据。</p><p>SDS的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 保存字符串的长度，不包含'\0'</span></span><br><span class="line">    <span class="keyword">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eg: 使用 SDS 存储了一个字符串 hello,对应的 len 就是5，同时也申请了5个为未使用的空间，所以 free 就是5。</p><p><img src="/images/redis/SDS%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.jpg" alt="SDS简单动态字符串"></p><blockquote><p>在 3.2 版本后，sds 会根据字符串实际的长度，选择不同的数据结构，以更好的提升内存效率。当前 sdshdr 结构分为 5 种子类型，分别为 sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64。其中 sdshdr5 只有 flags 和 buf 字段，其他几种类型的 len 和 alloc 采用从 uint8_t 到 uint64_t 的不同类型，以节省内存空间。</p></blockquote><h6 id="SDS-对比C字符串的优势"><a href="#SDS-对比C字符串的优势" class="headerlink" title="SDS 对比C字符串的优势"></a>SDS 对比C字符串的优势</h6><ul><li><strong>SDS可以常数级别获取字符串的长度</strong>  因为结构里面已经记录了字符串的长度，所以获取字符串的长度复杂度为O(1)，c 中字符串没记录长度，需要遍历整个长度，复杂度为O(N)。</li><li><strong>杜绝缓冲区溢出</strong>  如果在修改字符的时候，没有分配足够的内存大小，就很容易造成缓存溢出，内存越界。strcat 函数常见的错误就是数组越界，即两个字符串连接后，长度超过第一个字符串数组定义的长度，导致越界。SDS 中的空间分配策略可以杜绝这种情况，当对 SDS 进行修改时，API 会检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。空间的申请是自动完成的，所以就避免了缓存溢出。</li><li><strong>减少修改字符串时带来的内存分配次数</strong>  对于 C 字符串来说，如果修改字符串的长度，都需要重新执行内存分配操作；但是对于 Redis 数据库来说，如果频繁执行内存分配/释放操作，必然会对性能产生一定影响。为了避免 C 字符串的缺陷，SDS 采用了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。<ul><li><strong>空间预分配</strong> 空间预分配用于优化 SDS 的字符串增长操作，当 SDS 的 api 对 SDS 进行修改，同时需要进行空间扩展的时候，除了会给 SDS 分配修改需要的空间，同时还会给 SDS 分配额外的未使用空间。在对 SDS 空间进行扩展的时候，首先会判断未使用空间的大小是否能满足要求，如果足够，就不用在进行内存分配了，这样能够减少内存的重新分配的次数。<ul><li>如果对 SDS 修改之后，SDS 的长度小于1MB,那么程序分配和 len 同样大小的未使用空间，也就是这时候 SDS 中的 len 和 free 长度相同；</li><li>如果对 SDS 修改之后，SDS 的长度大于等于1MB,那么程序分配1MB的未使用空间。</li></ul></li><li><strong>惰性空间释放</strong> 惰性空间释放用于优化 SDS 字符串的缩短操作，当 SDS 的 API 需要缩短 SDS 保护的字符串时，程序并不会立即使用内存重分配来回收缩短后多出来的内存，而是使用 free 属性将这些字节的数量记录起来，等待之后的重新使用。</li></ul></li><li><strong>二进制安全</strong>  <strong>对于 C 字符串来说，字符串中不能包含空字符，否则最先被程序读入的空字符串被误认为是字符串结尾</strong>，这使得 C 字符串只能保存文本数据，而不能保存图片、音视频等二进制文件。对于 SDS 来说，所有 SDS 都会以处理二进制的方式来处理 SDS 保存在 buf 数组中的内容，程序不会对里面的内容做任何限制。</li><li><strong>兼容部分C字符串函数</strong>  SDS 末尾设置空字符的操作使得它可以和部分 C 字符串函数兼容。</li></ul><h5 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2 双向链表"></a>2 双向链表</h5><p>链表是一种很常见的数据结构，在很多高级语言中都能看到，Redis 中的 list 就用到了双向链表，当一个列表键包含了数量比较多的元素，或者是列表中包含的元素都是比较长的字符串的时，Redis 就会使用链表作为 list 的底层实现。</p><h5 id="3-字典-哈希表"><a href="#3-字典-哈希表" class="headerlink" title="3 字典 (哈希表)"></a>3 字典 (哈希表)</h5><p>redisDb 主要包括 2 个核心 dict 字典、3 个非核心 dict 字典、dbID 和其他辅助属性。2 个核心 dict 包括一个 dict 主字典和一个 expires 过期字典。主 dict 字典用来存储当前 DB 中的所有数据，它将 key 和各种数据类型的 value 关联起来，该 dict 也称 key space。过期字典用来存储过期时间 key，存的是 key 与过期时间的映射。日常的数据存储和访问基本都会访问到 redisDb 中的这两个 dict。3 个非核心 dict 包括一个字段名叫 blocking_keys 的阻塞 dict，一个字段名叫 ready_keys 的解除阻塞 dict，还有一个是字段名叫 watched_keys 的 watch 监控 dict。</p><p>Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希节点，每个哈希表节点就保存了字典中的一个键值对。使用哈希表就难免遇到哈希碰撞，两个key的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。<strong>Redis 解决哈希冲突的方式，就是链式哈希</strong>。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。随着写入的消息越来越多，哈希冲突的几率也随之升高，这时候就需要对哈希表进行扩容，Redis 中的扩容使用的是<strong>渐进式rehash</strong>。</p><p>其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p><ol><li>给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；</li><li>把哈希表1中的数据重新映射并拷贝到哈希表2中；</li><li>释放哈希表1的空间。</li></ol><p><img src="/images/redis/Redis%E7%9A%84rehash%E8%BF%87%E7%A8%8B.png" alt="Redis的rehash过程"></p><p>当然数据很大的话，一次迁移所有的数据，显然是不合理的，会造成Redis线程阻塞，无法服务其他请求。这里 Redis 使用的是渐进式 rehash。在 rehash 期间，每次执行添加，删除，查找或者更新操作时，除了对命令本身的处理，还会顺带将哈希表1中的数据拷贝到哈希表2中。从索引0开始，每执行一次操作命令，拷贝一个索引位置的数据。在进行 rehash 期间，删除，查找或者更新操作都会在两个哈希表中执行，添加操作就直接添加到哈希表2中了。查找会把两个哈希表都找一遍，直到找到或者两个都找不到。</p><h5 id="4-跳表"><a href="#4-跳表" class="headerlink" title="4 跳表"></a>4 跳表</h5><p>Redis 中的有序集合就是使用跳表来实现的。对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。</p><p>链表加多级索引的结构，就是跳表,跳表查询的时间复杂度是O(logn)。通过在每个节点中维持多个指向其他节点的指针，从而实现快速访问的节点的目的。</p><h5 id="5-整数数组"><a href="#5-整数数组" class="headerlink" title="5 整数数组"></a>5 整数数组</h5><p>整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。是 Redis 用户保存整数值的集合抽象数据结构，可以保存的类型是int16_t,int32_t,int64_t的整数值，并且保证集合中不会出现重复的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方法，指定当前存储的是 16 位，32 位，还是 64 位的整数</span></span><br><span class="line">    int32 encoding;</span><br><span class="line">    <span class="comment">// 集合中的元素数量</span></span><br><span class="line">    int32 length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int</span>&lt;T&gt; contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看，这个集合倒也没有什么特殊的点。这时候需要来看下整数集合的升级。</p><p>每当一个整数被添加到整数集合时，首先需要判断下 新元素的类型和集合中现有元素类型的长短，如果新元素是一个32位的数字，现有集合类型是16位的，那么就需要将整数集合进行升级，然后才能将新的元素加入进来。</p><p>优点：</p><ul><li>提升整数集合的灵活性，可以随意的添加整数，而不用关心整数的类型；</li><li>可以尽可能的节约内存。</li></ul><p>缺点：</p><ul><li>不支持降级，一旦对数组进行了升级，就会一直保持升级后的状态。</li></ul><h5 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6 压缩列表"></a>6 压缩列表</h5><p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个元素只包含少量的列表项，并且每个列表项是小整数值或者是长度比较短的字符串，redis 就会使用压缩列表来作为列表键的底层实现。</p><p>压缩列表(ziplist)的目的是为了节约内存，通过一片连续的内存空间来存储数据。这样看起来好像和数组很像，数组中每个节点的内存大小是一样的，对于压缩列表，每个节点的内存大小是不同的，每个节点可以保存字节数组或一个整数值。通过可变的节点内存大小，来节约内存的使用。</p><p><img src="/images/redis/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png" alt="压缩列表"></p><p>ziplist的结构：</p><ul><li><strong>zlbytes</strong>: 是压缩列表所占用的总内存字节数;</li><li><strong>zltail</strong> : 尾节点到起始位置的字节数，（目的是为了直接定位到尾节点，方便反向查询）</li><li><strong>zllen</strong> : 总共包含的节点/内存块数，也就是压缩列表的节点数量;</li><li><strong>entry</strong> : 是 ziplist 保存的各个数据节点，这些数据点长度随意;</li><li><strong>zlend</strong> : 是一个魔数 255，用来标记压缩列表的结束。</li></ul><p>由于 ziplist 是连续紧凑存储，没有冗余空间，所以插入新的元素需要 realloc 扩展内存，所以如果 ziplist 占用空间太大，realloc 重新分配内存和拷贝的开销就会很大，所以 ziplist 不适合存储过多元素，也不适合存储过大的字符串。</p><p>因此只有在元素数和 value 数都不大的时候，ziplist 才作为 hash 和 zset 的内部数据结构。其中 hash 使用 ziplist 作为内部数据结构的限制时，元素数默认不超过 512 个，value 值默认不超过 64 字节。可以通过修改配置来调整 hash_max_ziplist_entries 、hash_max_ziplist_value 这两个阀值的大小。zset 有序集合，使用 ziplist 作为内部数据结构的限制元素数默认不超过 128 个，value 值默认不超过 64 字节。可以通过修改配置来调整 zset_max_ziplist_entries 和 zset_max_ziplist_value 这两个阀值的大小。</p><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N)了</p><h6 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h6><p>压缩列表 ziplist 的存储节点 Entry 数据节点的结构：</p><p><img src="/images/redis/ziplist%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0.png" alt="ziplist连锁更新"></p><ol><li>previous_entry_length : 记录了前一个节点的长度<ol><li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节：前一节点的长度就保存在这一个字节里面；</li><li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节：其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li></ol></li><li>encoding : 记录了节点的 content 属性所保存数据的类型以及长度</li><li>content : 节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</li></ol><p>eg: 如果压缩列表中每个节点的长度都是250，因为是小于254，所以每个节点中的 previous_entry_length 长度1字节就能够保存了。</p><p>这时候，在头部节点插入了一个新的元素 entryNew，然后长度是大于254，那么后面的节点中 entry1 的 previous_entry_length 长度为1字节，就不能保存了，需要扩容成5字节，然后 entry1 节点进行扩容了，变成了254，所以后面的节点也就需要一次扩容，这就引发一连串的扩容。也就是连锁更新。</p><h4 id="为什么单线程还能很快"><a href="#为什么单线程还能很快" class="headerlink" title="为什么单线程还能很快"></a>为什么单线程还能很快</h4><p>Redis 是单线程，主要是指 Redis 的网络IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</p><p>多线程必然会面临对于共享资源的访问，这时候通常的做法就是加锁，虽然是多线程，这时候就会变成串行的访问。也就是多线程编程模式会面临的共享资源的并发访问控制问题。</p><p>同时多线程也会引入同步原语来保护共享资源的并发访问，代码的可维护性和易读性将会下降。</p><h4 id="基于多路复用的高性能I-O模型"><a href="#基于多路复用的高性能I-O模型" class="headerlink" title="基于多路复用的高性能I/O模型"></a>基于多路复用的高性能I/O模型</h4><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用 就是为了解决这个问题而出现的</p><p><strong>Linux 中的IO多路复用机制是指一个线程处理多个IO流。 多路是指网络连接，复用指的是同一个线程。</strong> 简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个IO流的效果。</p><p><strong>文件事件是对连接 socket 操作的一个抽象。</strong> 当端口监听 socket 准备 accept 新连接，或者连接 socket 准备好读取请求、写入响应、关闭时，就会产生一个文件事件。IO 多路复用程序负责同时监听多个 socket，当这些 socket 产生文件事件时，就会触发事件通知，文件分派器就会感知并获取到这些事件。</p><p>虽然多个文件事件可能会并发出现，但 IO 多路复用程序总会将所有产生事件的 socket 放入一个队列中，通过这个队列，有序的把这些文件事件通知给文件分派器。</p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个的函数，他们定义了这个事件发生时，服务器应该执行的动作。</p><p><img src="/images/redis/Redis%E4%B9%8Bio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg" alt="Redis之io多路复用"></p><p>Redis 封装了 4 种多路复用程序，每种封装实现都提供了相同的 API 实现。编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，这 3 个多路复用函数都直接使用系统内核内部的结构，可以服务数十万的文件描述符。</p><p>如果当前编译环境没有上述函数，就会选择 select 作为底层实现方案。select 方案的性能较差，事件发生时，会扫描全部监听的描述符，事件复杂度是 O(n)，并且只能同时服务有限个文件描述符，32 位机默认是 1024 个，64 位机默认是 2048 个，所以一般情况下，并不会选择 select 作为线上运行方案。</p><p><img src="/images/redis/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.jpg" alt="IO多路复用底层实现"></p><h4 id="单线程处理IO请求性能瓶颈"><a href="#单线程处理IO请求性能瓶颈" class="headerlink" title="单线程处理IO请求性能瓶颈"></a>单线程处理IO请求性能瓶颈</h4><ol><li>后台 Redis 通过监听处理事件队列中的消息，来单线程的处理命令，如果一个命令的执行时间很久，就会影响整个 server 的性能。</li></ol><p>耗时的操作命令有下面几种：<br>1、操作 bigkey：bigkey 在写入和删除的时候，需要的时间都会很长；<br>2、使用复杂度过高的命令；<br>3、大量 key 集中过期：Redis 的过期机制也是在主线程中执行的，大量 key 集中过期会导致处理一个请求时，耗时都在删除过期 key，耗时变长；<br>4、淘汰策略：淘汰策略也是在主线程执行的，当内存超过 Redis 内存上限后，每次写入都需要淘汰一些 key，也会造成耗时变长；<br>5、AOF 刷盘开启 always 机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢 Redis 的性能；<br>6、主从全量同步生成 RDB：虽然采用 fork 子进程生成数据快照，但 fork 这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</p><p>对于 bigkey，Redis 在4.0推出了 lazy-free 机制，把 bigkey 释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</p><ol start="2"><li>并发量非常大时，单线程读写客户端 IO 数据存在性能瓶颈<br>使用 Redis 时，几乎不存在 CPU 成为瓶颈的情况， Redis 主要受限于内存和网络。随着硬件水平的提升，Redis 中的性能慢慢主要出现在网络 IO 的读写上。虽然采用 IO 多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</li></ol><p>为了提升网络 IO 的读写性能，Redis 在6.0推出了多线程，同过多线程的 IO 来处理网络请求。不过需要注意的是这里的多线程仅仅是针对客户端的读写是并行的，Redis 处理事件队列中的命令，还是单线程处理的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 使用单线程，来避免共享资源的竞争，使用多路复用实现高性能的I/O，它是内存数据库，所有操作都在内存上完成，使用哈希表，跳表等一系列高效的数据结构，这些特性保证了 Redis 的高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis-中的查询速度为什么那么快呢？&quot;&gt;&lt;a href=&quot;#Redis-中的查询速度为什么那么快呢？&quot; class=&quot;headerlink&quot; title=&quot;Redis 中的查询速度为什么那么快呢？&quot;&gt;&lt;/a&gt;Redis 中的查询速度为什么那么快呢？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;因为它是内存数据库&lt;/li&gt;
&lt;li&gt;归功于它的数据结构（SDS简单动态字符串、链表、压缩列表、跳表、整数数组、哈希表）&lt;/li&gt;
&lt;li&gt;Redis是单线程（6.0版本引入多线程，通过多线程的 IO 来处理网络请求，但是处理事件队列的命令是单线程的）&lt;/li&gt;
&lt;li&gt;Redis中使用了多路复用&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="redis" scheme="https://xiebiao123.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redisson-分布式锁</title>
    <link href="https://xiebiao123.github.io/2022/04/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redisson/"/>
    <id>https://xiebiao123.github.io/2022/04/18/学习笔记/中间件/Redis/Redisson/</id>
    <published>2022-04-17T16:00:00.000Z</published>
    <updated>2022-04-18T05:54:38.162Z</updated>
    
    <content type="html"><![CDATA[<h4 id="加锁-redissonLock-lock"><a href="#加锁-redissonLock-lock" class="headerlink" title="加锁 redissonLock.lock()"></a>加锁 redissonLock.lock()</h4><h5 id="1-1-lock"><a href="#1-1-lock" class="headerlink" title="1.1 lock()"></a>1.1 lock()</h5><blockquote><p>当我们进入到 Redisson 的lock方法时，会走到下面的代码逻辑。</p><ol><li>尝试去获取锁。</li><li>获取锁成功的话，走1.2，去构建看门狗什么的。</li><li>获取锁失败的话，进入自旋，并等待相应的时间去重新获取锁，知道锁获取成功。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前线程id</span></span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 注意，这里传入了一个 -1L</span></span><br><span class="line">    Long ttl = <span class="keyword">this</span>.tryAcquire(-<span class="number">1L</span>, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 这里 ttl 不等于 null的时候，说明没有获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> (ttl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = <span class="keyword">this</span>.subscribe(threadId);</span><br><span class="line">        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.commandExecutor.syncSubscriptionInterrupted(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.commandExecutor.syncSubscription(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行自旋，然后再次尝试获取锁</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                ttl = <span class="keyword">this</span>.tryAcquire(-<span class="number">1L</span>, leaseTime, unit, threadId);</span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ((RedissonLockEntry)future.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException var13) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> var13;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ((RedissonLockEntry)future.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                    ((RedissonLockEntry)future.getNow()).getLatch().acquire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ((RedissonLockEntry)future.getNow()).getLatch().acquireUninterruptibly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.unsubscribe(future, threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-tryAcquire"><a href="#1-2-tryAcquire" class="headerlink" title="1.2 tryAcquire()"></a>1.2 tryAcquire()</h5><blockquote><p>这个方法进来之后执行的是 tryAcquireAsync 方法</p><ol><li>先去尝试获取锁。</li><li>获取锁成功的话，就去设置一个看门狗的定时任务，用于给锁续命用。</li><li>获取锁失败的话，就退出这个方法，走1.1，进入自旋状态重新获取锁。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RFuture ttlRemainingFuture;</span><br><span class="line">    <span class="comment">// 由于前面传入的值为 -1L ，所以这里不走</span></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        ttlRemainingFuture = <span class="keyword">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个方法获取锁，获取锁成功的话，则会返回null</span></span><br><span class="line">    <span class="comment">// 获取锁失败的话，会返回当前拥有锁的线程还有多长时间，进入 1.3</span></span><br><span class="line">        ttlRemainingFuture = <span class="keyword">this</span>.tryLockInnerAsync(waitTime, <span class="keyword">this</span>.internalLockLeaseTime, TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里主要就是当获取锁成功后，设置一个定时任务</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 剩余时间等于null，说明获取锁成功了</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置一个定时任务，走1.4</span></span><br><span class="line">                    <span class="keyword">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-tryLockInnerAsync"><a href="#1-3-tryLockInnerAsync" class="headerlink" title="1.3 tryLockInnerAsync()"></a>1.3 tryLockInnerAsync()</h5><blockquote><p>进来之后我们发现这里有一个lua脚本</p><ol><li>尝试获取锁，如果获取到了就创建定时任务，指定看门狗对相应的锁续命</li><li>如果获取锁失败，就返回拥有锁线程的剩余时间</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.evalWriteAsync(<span class="keyword">this</span>.getRawName(), LongCodec.INSTANCE, command, </span><br><span class="line">    <span class="comment">// 这里面的 KEYS[1] 就是我们在最开始获取的Redis的那把锁，看那个属性或者说是锁是否存在</span></span><br><span class="line">    <span class="string">"if (redis.call('exists', KEYS[1]) == 0) "</span> +</span><br><span class="line">        <span class="string">"then "</span> +</span><br><span class="line">        <span class="comment">// 如果不存在，走下面逻辑，给当前线程设置值加1，也就是1</span></span><br><span class="line">            <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">            <span class="string">"return nil; "</span> +</span><br><span class="line">        <span class="string">"end; "</span> +</span><br><span class="line">        <span class="comment">// 这块的意思是锁存在，但是获取锁的是当前线程，支持可重入锁</span></span><br><span class="line">        <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) "</span> +</span><br><span class="line">        <span class="string">"then "</span> +</span><br><span class="line">        <span class="comment">// 给当前线程的数值加1</span></span><br><span class="line">            <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">            <span class="string">"return nil; "</span> +</span><br><span class="line">        <span class="string">"end; "</span> +</span><br><span class="line">        <span class="comment">// 没有获取到锁，查看一下锁的有效期并返回</span></span><br><span class="line">        <span class="string">"return redis.call('pttl', KEYS[1]);"</span>, Collections.singletonList(<span class="keyword">this</span>.getRawName()), <span class="keyword">new</span> Object[]&#123;unit.toMillis(leaseTime), <span class="keyword">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-scheduleExpirationRenewal-long-threadId"><a href="#1-4-scheduleExpirationRenewal-long-threadId" class="headerlink" title="1.4 scheduleExpirationRenewal(long threadId)"></a>1.4 scheduleExpirationRenewal(long threadId)</h5><blockquote><p>主要作用就是去调用循环续命的那个方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RedissonBaseLock.ExpirationEntry entry = <span class="keyword">new</span> RedissonBaseLock.ExpirationEntry();</span><br><span class="line">    RedissonBaseLock.ExpirationEntry oldEntry = (RedissonBaseLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="keyword">this</span>.getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 走到这里，里面会递归调用这个方法续命，否则销毁，走1.5</span></span><br><span class="line">            <span class="keyword">this</span>.renewExpiration();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cancelExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-5-renewExpiration"><a href="#1-5-renewExpiration" class="headerlink" title="1.5 renewExpiration()"></a>1.5 renewExpiration()</h5><blockquote><p>这个方法的主要作用就是</p><ol><li>设置一个定时任务，超过指定时间的 1/3 就会循环调用一次。</li><li>判断当前线程是否存在，如果存在，根据指定的时间重置过期时间，如果不存在，说明任务已经执行完成，销毁看门狗线程。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedissonBaseLock.ExpirationEntry ee = (RedissonBaseLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="keyword">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里设置一个定时任务</span></span><br><span class="line">        Timeout task = <span class="keyword">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                RedissonBaseLock.ExpirationEntry ent = (RedissonBaseLock.ExpirationEntry)RedissonBaseLock.EXPIRATION_RENEWAL_MAP.get(RedissonBaseLock.<span class="keyword">this</span>.getEntryName());</span><br><span class="line">                <span class="keyword">if</span> (ent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Long threadId = ent.getFirstThreadId();</span><br><span class="line">                    <span class="comment">// 给线程续命，里面调用set方法充重置线程时间</span></span><br><span class="line">                    <span class="keyword">if</span> (threadId != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        RFuture&lt;Boolean&gt; future = RedissonBaseLock.<span class="keyword">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                RedissonBaseLock.log.error(<span class="string">"Can't update lock "</span> + RedissonBaseLock.<span class="keyword">this</span>.getRawName() + <span class="string">" expiration"</span>, e);</span><br><span class="line">                                RedissonBaseLock.EXPIRATION_RENEWAL_MAP.remove(RedissonBaseLock.<span class="keyword">this</span>.getEntryName());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                <span class="comment">// 如果线程还存在，就递归调用并续命</span></span><br><span class="line">                                    RedissonBaseLock.<span class="keyword">this</span>.renewExpiration();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 如果线程不存在，就关闭销毁线程</span></span><br><span class="line">                                    RedissonBaseLock.<span class="keyword">this</span>.cancelExpirationRenewal((Long)<span class="keyword">null</span>);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="comment">// 每次过设置时间的 1/3 时，就会再次执行定时任务</span></span><br><span class="line"><span class="keyword">this</span>.internalLockLeaseTime / <span class="number">3L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-解锁-redissonLock-unlock"><a href="#2-解锁-redissonLock-unlock" class="headerlink" title="2. 解锁 redissonLock.unlock()"></a>2. 解锁 redissonLock.unlock()</h4><h5 id="2-1、unlock"><a href="#2-1、unlock" class="headerlink" title="2.1、unlock()"></a>2.1、unlock()</h5><blockquote><p>主方法，调用 unlockAsync() 方法，走2.2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.get(<span class="keyword">this</span>.unlockAsync(Thread.currentThread().getId()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RedisException var2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var2.getCause() <span class="keyword">instanceof</span> IllegalMonitorStateException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IllegalMonitorStateException)var2.getCause();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、unlockAsync-long-threadId"><a href="#2-2、unlockAsync-long-threadId" class="headerlink" title="2.2、unlockAsync(long threadId)"></a>2.2、unlockAsync(long threadId)</h5><blockquote><ol><li>修改状态，释放锁等，走2.3</li><li>删除线程，释放一些其它资源</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise();</span><br><span class="line">    <span class="comment">// 解锁的主要操作，走2.3</span></span><br><span class="line">    RFuture&lt;Boolean&gt; future = <span class="keyword">this</span>.unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 关闭这个锁的线程资源什么的</span></span><br><span class="line">        <span class="keyword">this</span>.cancelExpirationRenewal(threadId);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"attempt to unlock lock, not locked by current thread by node id: "</span> + <span class="keyword">this</span>.id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.trySuccess((Object)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、unlockInnerAsync"><a href="#2-3、unlockInnerAsync" class="headerlink" title="2.3、unlockInnerAsync()"></a>2.3、unlockInnerAsync()</h5><blockquote><ol><li>主要对锁的状态进行修改，lock一次就加1，unlock一次就减1。</li><li>当减到0的时候就删除这个数据，就是释放锁，并广播其它线程可以加锁了。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.evalWriteAsync(<span class="keyword">this</span>.getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, </span><br><span class="line">    <span class="comment">// 判断当前这个锁是否存在</span></span><br><span class="line">    <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) "</span> +</span><br><span class="line">    <span class="string">"then "</span> +</span><br><span class="line">    <span class="comment">// 如果等于0，说明锁已经不存在了，返回null</span></span><br><span class="line">        <span class="string">"return nil;"</span> +</span><br><span class="line">    <span class="string">"end; "</span> +</span><br><span class="line">    <span class="comment">// 定义一个本地变量对锁的状态减去1，并存储在counter中</span></span><br><span class="line">    <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">    <span class="comment">// 如果counter大于0</span></span><br><span class="line">    <span class="string">"if (counter &gt; 0) "</span> +</span><br><span class="line">    <span class="string">"then "</span> +</span><br><span class="line">    <span class="comment">// 设置一个过期时间并返回0</span></span><br><span class="line">        <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">        <span class="string">"return 0; "</span> +</span><br><span class="line">    <span class="string">"else "</span> +</span><br><span class="line">    <span class="comment">// 删除掉这个锁，并广播</span></span><br><span class="line">        <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">        <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">        <span class="string">"return 1; "</span> +</span><br><span class="line">    <span class="string">"end; "</span> +</span><br><span class="line">    <span class="string">"return nil;"</span>, Arrays.asList(<span class="keyword">this</span>.getRawName(), <span class="keyword">this</span>.getChannelName()), <span class="keyword">new</span> Object[]&#123;LockPubSub.UNLOCK_MESSAGE, <span class="keyword">this</span>.internalLockLeaseTime, <span class="keyword">this</span>.getLockName(threadId)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redisson-实现的常见锁"><a href="#Redisson-实现的常见锁" class="headerlink" title="Redisson 实现的常见锁"></a>Redisson 实现的常见锁</h4><ol><li>重入锁</li><li>公平锁与非公平锁</li><li>联锁 多个锁组成一个锁</li><li>红锁 多数节点获取锁成功，才算获取锁成功</li><li>读写锁</li></ol><h4 id="Redisson-实现延迟队列"><a href="#Redisson-实现延迟队列" class="headerlink" title="Redisson 实现延迟队列"></a>Redisson 实现延迟队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟队列与阻塞队列绑定</span></span><br><span class="line">RBlockingDeque&lt;String&gt; blockingDeque = redissonClient.getBlockingDeque(Constant.RedissonQueueName);</span><br><span class="line">RDelayedQueue&lt;String&gt; rDelayedQueue = redissonClient.getDelayedQueue(blockingDeque);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环从阻塞队列中获取数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    RBlockingDeque&lt;String&gt; blockingDeque = redissonClient.getBlockingDeque(Constant.RedissonQueueName);</span><br><span class="line">    <span class="keyword">if</span> (blockingDeque != <span class="keyword">null</span> &amp;&amp; !blockingDeque.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//本汪说下，此处我们所取到的element，就是我们 rDelayedQueue.offer(value,secondTTL,TimeUnit.SECONDS); 放进去的value了，</span></span><br><span class="line">        String element = blockingDeque.poll();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;加锁-redissonLock-lock&quot;&gt;&lt;a href=&quot;#加锁-redissonLock-lock&quot; class=&quot;headerlink&quot; title=&quot;加锁 redissonLock.lock()&quot;&gt;&lt;/a&gt;加锁 redissonLock.lock()&lt;/
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="redisson" scheme="https://xiebiao123.github.io/tags/redisson/"/>
    
  </entry>
  
  <entry>
    <title>服务降级熔断限流</title>
    <link href="https://xiebiao123.github.io/2022/02/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81/"/>
    <id>https://xiebiao123.github.io/2022/02/15/学习笔记/微服务/服务降级熔断限流/</id>
    <published>2022-02-14T16:00:00.000Z</published>
    <updated>2022-02-16T10:17:14.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h4 id="限流的指标"><a href="#限流的指标" class="headerlink" title="限流的指标"></a>限流的指标</h4><ol><li>TPS 每秒完成的事务数</li><li>HPS 每秒请求数，指每秒钟服务端收到客户端的请求数量</li><li>QPS 服务端每秒能够响应的客户端查询请求数量</li></ol><h4 id="限流的方法"><a href="#限流的方法" class="headerlink" title="限流的方法"></a>限流的方法</h4><ul><li><strong>流量计数器</strong>  这是最简单直接的方法，比如限制每秒请求数量100，超过100的请求就拒绝掉</li><li><strong>滑动时间窗口</strong> 滑动时间窗口算法是目前比较流行的限流算法，主要思想是把时间看做是一个向前滚动的窗口，如下图：<br><img src="/images/java/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81.png" alt="滑动窗口限流"></li></ul><p>开始的时候，我们把t1~t5看做一个时间窗口，每个窗口1s，如果我们定的限流目标是每秒50个请求，那t1~t5这个窗口的请求总和不能超过250个。这个窗口是滑动的，下一秒的窗口成了t2~t6，这时把t1时间片的统计抛弃，加入t6时间片进行统计。这段时间内的请求数量也不能超过250个。</p><ul><li><strong>漏桶算法</strong>  在客户端的请求发送到服务器之前，先用漏桶缓存起来，这个漏桶可以是一个长度固定的队列，这个队列中的请求均匀的发送到服务端。如果客户端的请求速率太快，漏桶的队列满了，就会被拒绝掉，或者走降级处理逻辑。这样服务端就不会受到突发流量的冲击。</li><li><strong>令牌桶算法</strong> 令牌桶算法就跟病人去医院看病一样，找医生之前需要先挂号，而医院每天放的号是有限的。当天的号用完了，第二天又会放一批号</li><li><strong>分布式限流</strong> 如果我们把令牌桶单独保存在一个地方(比如redis中)供整个分布式系统用，那客户端在调用组合服务，组合服务调用订单、库存和账户服务都需要跟令牌桶交互，交互次数明显增加了很多。有一种改进就是客户端调用组合服务之前首先获取四个令牌，调用组合服务时减去一个令牌并且传递给组合服务三个令牌，组合服务调用下面三个服务时依次消耗一个令牌</li><li>hystrix限流<ul><li>线程池</li><li>信号量</li></ul></li><li>sentinel限流<ul><li>信号量</li></ul></li></ul><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><h4 id="断路器的三种状态"><a href="#断路器的三种状态" class="headerlink" title="断路器的三种状态"></a>断路器的三种状态</h4><ol><li><strong>CLOSED 关闭状态（默认）</strong></li><li><strong>OPEN 打开状态</strong></li><li><strong>HALF OPEN 半开闭状态</strong></li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>服务故障或者升级时，让客户端快速失败</li><li>自定义失败处理逻辑</li><li>响应耗时较长，客户端设置的read timeout会比较长，防止客户端大量重试请求导致的连接、线程资源不能释放</li></ol><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li>针对不同的异常，定义不同的熔断后的处理逻辑</li><li>设置熔断的时长，超过这个时长以后服务切换为HALF OPEN状态进行重试</li><li>记录请求失败的日志，提供监控使用</li><li>重试时，可以使用之前失败的请求进行重试，单一定要注意业务上是否允许这样做</li></ol><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>在服务发生熔断后，一般会让请求走事先配置的处理方法，这个处理方法就是一个降级逻辑。服务降级是对非核心、非关键的服务进行降级。</p><h4 id="使用的场景"><a href="#使用的场景" class="headerlink" title="使用的场景"></a>使用的场景</h4><ol><li>监控系统检测到突增流量，为了避免非核心业务功能消耗系统资源，关闭这些非核心功能</li><li>暂时关闭某些定时任务，以节省系统资源</li></ol><h4 id="降级的方法"><a href="#降级的方法" class="headerlink" title="降级的方法"></a>降级的方法</h4><ol><li>hystrix降级</li><li>sentinel降级</li></ol><h3 id="sentinel-和-Hystrix-对比"><a href="#sentinel-和-Hystrix-对比" class="headerlink" title="sentinel 和 Hystrix 对比"></a>sentinel 和 Hystrix 对比</h3><table><thead><tr><th align="center"></th><th></th><th></th></tr></thead><tbody><tr><td align="center">隔离策略</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td align="center">限流</td><td>基于QPS、调用关系的限流</td><td>有限的支持，基于线程池、信号量的上限</td></tr><tr><td align="center">规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td align="center">系统负载保护</td><td>支持</td><td>不支持</td></tr><tr><td align="center">生态</td><td>活跃</td><td>Hystrix目前已经宣布不再主动开发，处于维护模式中</td></tr><tr><td align="center">熔断降级策略</td><td>基于响应时间或失败比率</td><td>基于失败比率</td></tr><tr><td align="center">流量整形</td><td>支持慢启动、匀速器模式</td><td>不支持</td></tr><tr><td align="center">注解支持</td><td>支持</td><td>支持</td></tr><tr><td align="center">控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>实时监控Hystrix指标</td></tr><tr><td align="center">扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td align="center">常见框架适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC 等</td><td>Servlet、Spring Cloud Netflix</td></tr><tr><td align="center">实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于RxJava）</td></tr></tbody></table><p>Sentinel在规则配置、控制台上的优势可以很好的解决现存问题中的配置热加载、配置项较复杂以及缺乏可视化监控的问题。此外Spring Cloud Alibaba Sentinel相比Spring Cloud Netflix同时提供了Feign的支持，此外还提供了对RestTemplate的支持。相比较于Hystrix，利用Sentinel集成RestTemplate和HttpClientUtils会更加容易。结合Hystrix已经进入维护模式，所以我们可以采用sentinel为主要的限流、熔断、降级的解决方案。</p><h4 id="接入sentinel"><a href="#接入sentinel" class="headerlink" title="接入sentinel"></a>接入sentinel</h4><h5 id="为什么需要改造sentinel"><a href="#为什么需要改造sentinel" class="headerlink" title="为什么需要改造sentinel"></a>为什么需要改造sentinel</h5><p>为什么需要对 Sentinel 进行改造呢？主要是因为所有规则都只能通过 Nacos 界面或 Apollo 界面来完成修改才能得到持久化存储，而在 Sentinel Dashboard 中修改限流规则虽然可以生效，但是不会被持久化到配置中心。而在这两个配置中心里存储的数据是一个 Json 格式，当存储的规则越来越多，对该 Json 配置的可读性与可维护性会变的越来越差。</p><h5 id="改造前后的数据流图"><a href="#改造前后的数据流图" class="headerlink" title="改造前后的数据流图"></a>改造前后的数据流图</h5><p><img src="/images/java/sentinel%E6%94%B9%E9%80%A0%E5%89%8D%E5%90%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="改造前后的数据流图"></p><ul><li>蓝色箭头 代表了限流规则由配置中心发起修改的更新路径</li><li>橙色箭头 代表了限流规则由 Sentinel Dashboard 发起修改的更新路径</li><li>绿色箭头 为公共公共部分，即不论从配置中心修改，还是从 Sentinel Dashboard 修改都会触发的操作</li></ul><h5 id="改造的核心点"><a href="#改造的核心点" class="headerlink" title="改造的核心点"></a>改造的核心点</h5><ol><li>Sentinel dashboard 控制台：<ul><li>Sentinel dashboard 控制台将规则写入到 apollo/nacos 配置中心进行持久化</li><li>Sentinel dashboard 能实时更新 apollo/nacos 控制台所修改的规则</li></ul></li><li>Sentinel Client：<ul><li>Sentinel Client 实时更新 apollo/nacos 配置中心所修改的规则</li></ul></li></ol><h6 id="Sentinel-dashboard的改造"><a href="#Sentinel-dashboard的改造" class="headerlink" title="Sentinel dashboard的改造"></a>Sentinel dashboard的改造</h6><ol><li>从官网下载源码到本地进行改造 <a href="https://github.com/alibaba/Sentinel/tree/1.8.3" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/tree/1.8.3</a></li><li>sentinel dashboard 添加 apollo 依赖与配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-openapi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>引入之后，在 sentinel-dashboard 的配置文件添加 apollo 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># apollo的中配置的appId</span><br><span class="line">app.id=sentinel-rules</span><br><span class="line"># 如果apollo配置中心控制台的访问地址</span><br><span class="line">apollo.meta=http://portal.xxx.net</span><br><span class="line"># token获取方法下文会介绍</span><br><span class="line">apollo.token=ccc082b44f06f2ae9552bf67a710f36c36e6b777</span><br><span class="line"># apollo的登录用户</span><br><span class="line">apollo.user=apollo</span><br><span class="line"># apollo的集群名称 没有的话请使用default</span><br><span class="line">apollo.clusterName=default</span><br><span class="line"># apollo的命名空间 默认使用application,但考虑到该空间需要给所有项目共同使用，因此单独创建了一个公共空间</span><br><span class="line">apollo.namespaceName=sentinel-rules</span><br></pre></td></tr></table></figure><ol start="3"><li>规则在 Apollo 的编码与存储配置</li></ol><p>sentinel-dashboard 中Apollo java配置项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.rule.apollo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.ApiDefinitionEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.GatewayFlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.AuthorityRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.DegradeRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.FlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.ParamFlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.SystemRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.domain.cluster.request.ClusterAppAssignMap;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.Converter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.ctrip.framework.apollo.openapi.client.ApolloOpenApiClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfig</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.meta&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String portalUrl;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.token&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流控规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;FlowRuleEntity&gt;, String&gt; flowRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流控规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;FlowRuleEntity&gt;&gt; flowRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, FlowRuleEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 降级规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;DegradeRuleEntity&gt;, String&gt; degradeRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 降级规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;DegradeRuleEntity&gt;&gt; degradeRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, DegradeRuleEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;AuthorityRuleEntity&gt;, String&gt; authorityRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;AuthorityRuleEntity&gt;&gt; authorityRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, AuthorityRuleEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;SystemRuleEntity&gt;, String&gt; systemRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;SystemRuleEntity&gt;&gt; systemRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, SystemRuleEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 热点规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;ParamFlowRuleEntity&gt;, String&gt; paramFlowRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 热点规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;ParamFlowRuleEntity&gt;&gt; paramFlowRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, ParamFlowRuleEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群流控规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;ClusterAppAssignMap&gt;, String&gt; clusterGroupEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群流控规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;ClusterAppAssignMap&gt;&gt; clusterGroupEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, ClusterAppAssignMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API管理分组编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;ApiDefinitionEntity&gt;, String&gt; apiDefinitionEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API管理分组解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;ApiDefinitionEntity&gt;&gt; apiDefinitionEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, ApiDefinitionEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网关流控规则编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;GatewayFlowRuleEntity&gt;, String&gt; gatewayFlowRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网关流控规则解码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;GatewayFlowRuleEntity&gt;&gt; gatewayFlowRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, GatewayFlowRuleEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApolloOpenApiClient <span class="title">apolloOpenApiClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApolloOpenApiClient client = ApolloOpenApiClient.newBuilder()</span><br><span class="line">            .withPortalUrl(portalUrl)</span><br><span class="line">            .withToken(token)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sentinel 规则在 Apollo 中存储的 key 值的前/后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.rule.apollo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfigUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网关-api分组id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GATEWAY_API_GROUP_DATA_ID_POSTFIX = <span class="string">"gw-api-group-rules"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网关-流控规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GATEWAY_FLOW_DATA_ID_POSTFIX = <span class="string">"gw-flow-rules"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流控规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLOW_DATA_ID_POSTFIX = <span class="string">"flow-rules"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 降级规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEGRADE_DATA_ID_POSTFIX = <span class="string">"degrade-rules"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 热点规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_FLOW_DATA_ID_POSTFIX = <span class="string">"param-flow-rules"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_DATA_ID_POSTFIX = <span class="string">"system-rules"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权规则id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY_DATA_ID_POSTFIX = <span class="string">"authority-rules"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群流控id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLUSTER_GROUP_DATA_ID_POSTFIX = <span class="string">"cluster-group-rules"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ApolloConfigUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getGatewayFlowDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, GATEWAY_FLOW_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getGatewayApiGroupDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, GATEWAY_API_GROUP_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getClusterGroupDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, CLUSTER_GROUP_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFlowDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, FLOW_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDegradeDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, DEGRADE_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getParamFlowDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, PARAM_FLOW_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSystemDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, SYSTEM_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getAuthorityDataId</span><span class="params">(String appName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, appName, AUTHORITY_DATA_ID_POSTFIX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>新增 Provider 与 Publisher：</li></ol><p>新增 Provider，从 Apollo 配置中心查询持久化的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"flowRuleApolloProvider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowRuleApolloProvider</span> <span class="keyword">implements</span> <span class="title">DynamicRuleProvider</span>&lt;<span class="title">List</span>&lt;<span class="title">FlowRuleEntity</span>&gt;&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApolloOpenApiClient apolloOpenApiClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Converter&lt;String, List&lt;FlowRuleEntity&gt;&gt; converter;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app.id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.profiles.active&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String env;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.clusterName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clusterName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.namespaceName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namespaceName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;FlowRuleEntity&gt; <span class="title">getRules</span><span class="params">(String appName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String flowDataId = ApolloConfigUtil.getFlowDataId(appName);</span><br><span class="line"> </span><br><span class="line">        OpenNamespaceDTO openNamespaceDTO = apolloOpenApiClient.getNamespace(appId, env, clusterName, namespaceName);</span><br><span class="line"> </span><br><span class="line">        String rules = openNamespaceDTO</span><br><span class="line">                .getItems()</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(p -&gt; p.getKey().equals(flowDataId))</span><br><span class="line">                .map(OpenItemDTO::getValue)</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(<span class="string">""</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(rules)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> converter.convert(rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 Publisher，将流控规则持久化到 Apollo 配置中心里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"flowRuleApolloPublisher"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowRuleApolloPublisher</span> <span class="keyword">implements</span> <span class="title">DynamicRulePublisher</span>&lt;<span class="title">List</span>&lt;<span class="title">FlowRuleEntity</span>&gt;&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApolloOpenApiClient apolloOpenApiClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Converter&lt;List&lt;FlowRuleEntity&gt;, String&gt; converter;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;app.id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.profiles.active&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String env;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.user&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.clusterName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clusterName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apollo.namespaceName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namespaceName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String app, List&lt;FlowRuleEntity&gt; rules)</span></span>&#123;</span><br><span class="line">        AssertUtil.notEmpty(app, <span class="string">"app name cannot be empty"</span>);</span><br><span class="line">        <span class="keyword">if</span> (rules == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        filterField(rules);</span><br><span class="line">        <span class="comment">// Increase the configuration</span></span><br><span class="line">        String flowDataId = ApolloConfigUtil.getFlowDataId(app);</span><br><span class="line">        OpenItemDTO openItemDTO = <span class="keyword">new</span> OpenItemDTO();</span><br><span class="line">        openItemDTO.setKey(flowDataId);</span><br><span class="line">        openItemDTO.setValue(converter.convert(rules));</span><br><span class="line">        openItemDTO.setComment(<span class="string">"Program auto-join"</span>);</span><br><span class="line">        openItemDTO.setDataChangeCreatedBy(user);</span><br><span class="line">        apolloOpenApiClient.createOrUpdateItem(appId, env, clusterName, namespaceName, openItemDTO);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Release configuration</span></span><br><span class="line">        NamespaceReleaseDTO namespaceReleaseDTO = <span class="keyword">new</span> NamespaceReleaseDTO();</span><br><span class="line">        namespaceReleaseDTO.setEmergencyPublish(<span class="keyword">true</span>);</span><br><span class="line">        namespaceReleaseDTO.setReleaseComment(<span class="string">"Modify or add configurations"</span>);</span><br><span class="line">        namespaceReleaseDTO.setReleasedBy(user);</span><br><span class="line">        namespaceReleaseDTO.setReleaseTitle(<span class="string">"Modify or add configurations"</span>);</span><br><span class="line">        apolloOpenApiClient.publishNamespace(appId, env, clusterName, namespaceName, namespaceReleaseDTO);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤不必要的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterField</span><span class="params">(List&lt;FlowRuleEntity&gt; rules)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对不必要的信息进行过滤</span></span><br><span class="line">        <span class="keyword">for</span> (FlowRuleEntity rule : rules) &#123;</span><br><span class="line">            rule.setGmtCreate(<span class="keyword">null</span>);</span><br><span class="line">            rule.setGmtModified(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中引入 Provider 和 Publisher：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleApolloProvider"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"flowRuleApolloPublisher"</span>)</span><br><span class="line"><span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure><p>修改 controller 的查询接口，改由从 apollo 中查询 sentinel 的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询流控配置，用于展示在sentinel-dashboard上 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/rules"</span>)</span><br><span class="line"><span class="meta">@AuthAction</span>(PrivilegeType.READ_RULE)</span><br><span class="line"><span class="keyword">public</span> Result&lt;List&lt;FlowRuleEntity&gt;&gt; apiQueryMachineRules(<span class="meta">@RequestParam</span> String app, <span class="meta">@RequestParam</span> String ip, <span class="meta">@RequestParam</span> Integer port) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmpty(app))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">"app can't be null or empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isEmpty(ip))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">"ip can't be null or empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">"port can't be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;FlowRuleEntity&gt; rules = ruleProvider.getRules(app);</span><br><span class="line">        <span class="keyword">if</span> (rules != <span class="keyword">null</span> &amp;&amp; !rules.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (FlowRuleEntity entity : rules)</span><br><span class="line">            &#123;</span><br><span class="line">                entity.setApp(app);</span><br><span class="line">                <span class="keyword">if</span> (entity.getClusterConfig() != <span class="keyword">null</span> &amp;&amp; entity.getClusterConfig().getFlowId() != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    entity.setId(entity.getClusterConfig().getFlowId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        repository.saveAll(rules);</span><br><span class="line">        <span class="keyword">return</span> Result.ofSuccess(rules);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable throwable)</span><br><span class="line">    &#123;</span><br><span class="line">        logger.error(<span class="string">"Error when querying flow rules"</span>, throwable);</span><br><span class="line">        <span class="keyword">return</span> Result.ofThrowable(-<span class="number">1</span>, throwable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 controller 的新增或修改接口，每次新增或修改都同步到 Apollo 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布限流配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">publishRules</span><span class="params">(String app, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">    List&lt;FlowRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rulePublisher.publish(app, rules);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinelApiClient.setFlowRuleOfMachineAsync(app, ip, port, rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Apollo配置"><a href="#Apollo配置" class="headerlink" title="Apollo配置"></a>Apollo配置</h6><ol><li><p>配置 sentinel-dashboard 的 Apollo 空间<br><img src="/images/java/%E9%85%8D%E7%BD%AEsentinel-dashboard%E7%9A%84Apollo%E7%A9%BA%E9%97%B4.png" alt="配置sentinel-dashboard的Apollo空间"></p></li><li><p>创建sentinel-dashboard项目的apollo应用<br><img src="/images/java/sentinel-dashboard%E9%A1%B9%E7%9B%AE%E7%9A%84apollo%E5%BA%94%E7%94%A8.png" alt="sentinel-dashboard项目的apollo应用"></p></li><li><p>创建基于sentinel-dashboard的开放授权信息token<br><img src="/images/java/Apollo%E6%8E%88%E6%9D%831.png" alt="Apollo授权1"><br><img src="/images/java/Apollo%E6%8E%88%E6%9D%832.png" alt="Apollo授权2"><br><img src="/images/java/Apollo%E6%8E%88%E6%9D%833.png" alt="Apollo授权3"></p></li></ol><h6 id="spring-boot-集成-sentinel-并持久化规则到-apollo-中"><a href="#spring-boot-集成-sentinel-并持久化规则到-apollo-中" class="headerlink" title="spring boot 集成 sentinel 并持久化规则到 apollo 中"></a>spring boot 集成 sentinel 并持久化规则到 apollo 中</h6><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--apollo--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-apollo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># sentinel + apollo进行规则持久化，RulesKey指定该规则在apollo中key的名称，命名格式需与sentinel-dashboard配置的格式保持一致</span><br><span class="line">sentinel.datasource.rules.apollo.namespace-name = EDU001.sentinel-rules</span><br><span class="line"></span><br><span class="line"># sentinel看板的地址</span><br><span class="line">spring.cloud.sentinel.transport.dashboard = 112.74.98.151:80</span><br><span class="line"># 开启对sentinel看板的饥饿式加载</span><br><span class="line">spring.cloud.sentinel.eager = true</span><br><span class="line"> </span><br><span class="line"># 此项为该项目在配置中心的项目名</span><br><span class="line">app.id=gateway-bbk</span><br><span class="line"># 加载的配置文件名，需引入 sentinel-dashboard 配置的公共空间</span><br><span class="line">apollo.bootstrap.namespaces=application,EDU001.sentinel-rules</span><br><span class="line">apollo.bootstrap.enabled=true</span><br><span class="line"># 指定apollo的注册地址：</span><br><span class="line">#本地开发环境 Local environment</span><br><span class="line">local.meta=http://47.112.238.105:8004</span><br><span class="line">#开发联调环境 Development environment</span><br><span class="line">dev.meta=http://172.18.227.113:8080</span><br><span class="line">#功能验收测试环境 Feature Acceptance Test environment</span><br><span class="line">fat.meta=http://172.18.227.115:8080</span><br><span class="line">#生产环境 Production environment</span><br><span class="line">pro.meta=http://xxxx.xxx.net</span><br></pre></td></tr></table></figure><h6 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h6><p>在 sentinel-dashboard 控制台中添加新的规则：<br><img src="/images/java/sentinel%E6%B5%8B%E8%AF%95.png" alt="sentinel测试"></p><p>同步至Apollo中：<br><img src="/images/java/sentinel%E6%B5%8B%E8%AF%952.png" alt="sentinel测试2"></p><h4 id="SentinelResource-详解"><a href="#SentinelResource-详解" class="headerlink" title="@SentinelResource 详解"></a>@SentinelResource 详解</h4><p><img src="/images/java/@sentinelResource.png" alt="@sentinelResource"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;限流&quot;&gt;&lt;a href=&quot;#限流&quot; class=&quot;headerlink&quot; title=&quot;限流&quot;&gt;&lt;/a&gt;限流&lt;/h3&gt;&lt;h4 id=&quot;限流的指标&quot;&gt;&lt;a href=&quot;#限流的指标&quot; class=&quot;headerlink&quot; title=&quot;限流的指标&quot;&gt;&lt;/a&gt;限流的指
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="sentinel" scheme="https://xiebiao123.github.io/tags/sentinel/"/>
    
      <category term="hystrix" scheme="https://xiebiao123.github.io/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Docker Desktop</title>
    <link href="https://xiebiao123.github.io/2022/02/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker/DockerDesktop/"/>
    <id>https://xiebiao123.github.io/2022/02/09/学习笔记/docker/DockerDesktop/</id>
    <published>2022-02-08T16:00:00.000Z</published>
    <updated>2022-02-14T02:26:51.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker-Desktop-安装"><a href="#Docker-Desktop-安装" class="headerlink" title="Docker Desktop 安装"></a>Docker Desktop 安装</h3><h3 id="Docker-Desktop安装软件"><a href="#Docker-Desktop安装软件" class="headerlink" title="Docker Desktop安装软件"></a>Docker Desktop安装软件</h3><h4 id="挂载mysql"><a href="#挂载mysql" class="headerlink" title="挂载mysql"></a><a href="https://blog.csdn.net/yaoyuncn/article/details/103914588" target="_blank" rel="noopener">挂载mysql</a></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. 安装镜像</span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. 创建目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3. 获取默认的mysql配置</span><br><span class="line">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest --default-authentication-plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 4. 拷贝文件到本地目录</span><br><span class="line">docker cp mysql:/etc/mysql/my.cnf D:/docker/mysql/conf/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>5.修改配置文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 表名大小写是否敏感</span><br><span class="line">lower_case_table_names=1</span><br><span class="line"><span class="meta">#</span> 是否开启慢查询日志</span><br><span class="line">slow_query_log=ON</span><br><span class="line"><span class="meta">#</span> 慢查询的阈值，单位秒</span><br><span class="line">long_query_time=3</span><br><span class="line"><span class="meta">#</span> 是否记录未使用索引的查询语句，记录在慢查询日志</span><br><span class="line">log_queries_not_using_indexes=OFF</span><br><span class="line"><span class="meta">#</span> 错误日志</span><br><span class="line">log_error=/var/lib/mysql/error.log</span><br><span class="line"><span class="meta">#</span> 慢查询日志</span><br><span class="line">slow_query_log_file=var/lib/mysql/slowquery.log</span><br><span class="line"><span class="meta">#</span> 允许导入导出</span><br><span class="line">secure-file-priv=''</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 6. 重新创建容器</span><br><span class="line">docker stop mysql</span><br><span class="line">docker rm mysql</span><br><span class="line"></span><br><span class="line">docker run --name mysql -p 3306:3306 -v /d/docker/mysql/data:/var/lib/mysql/ -v /d/docker/mysql/conf/my.cnf:/etc/mysql/my.cnf -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest --default-authentication-plugin=mysql_native_password</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker-Desktop-安装&quot;&gt;&lt;a href=&quot;#Docker-Desktop-安装&quot; class=&quot;headerlink&quot; title=&quot;Docker Desktop 安装&quot;&gt;&lt;/a&gt;Docker Desktop 安装&lt;/h3&gt;&lt;h3 id=&quot;Docke
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="docker" scheme="https://xiebiao123.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>缓存</title>
    <link href="https://xiebiao123.github.io/2021/01/05/%E9%9D%A2%E8%AF%95%E4%B8%93%E6%A0%8F/%E7%BC%93%E5%AD%98/"/>
    <id>https://xiebiao123.github.io/2021/01/05/面试专栏/缓存/</id>
    <published>2021-01-04T16:00:00.000Z</published>
    <updated>2022-01-11T09:22:13.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用缓存？"><a href="#为什么要使用缓存？" class="headerlink" title="为什么要使用缓存？"></a>为什么要使用缓存？</h4><ol><li>高性能<ul><li>同一条数据多次查询，第二次查询用缓存耗时缩短</li></ul></li><li>高并发<ul><li>数据库并发能力有限（2000/s）,缓存是走内存的天然高并发（4w/s）</li></ul></li></ol><h4 id="用了缓存会有什么问题？"><a href="#用了缓存会有什么问题？" class="headerlink" title="用了缓存会有什么问题？"></a>用了缓存会有什么问题？</h4><ul><li>缓存与数据库双写不一致的问题</li><li>缓存的雪崩</li><li>缓存的穿透</li><li>缓存的并发竞争</li></ul><h4 id="为什么redis单线程模型也能够效率这么高？"><a href="#为什么redis单线程模型也能够效率这么高？" class="headerlink" title="为什么redis单线程模型也能够效率这么高？"></a>为什么redis单线程模型也能够效率这么高？</h4><ol><li>纯内存操作</li><li>核心是基于非阻塞的IO多路服用机制</li><li>单线程反而避免了多线程的频繁上下文切换问题</li></ol><p><img src="/images/%E9%9D%A2%E8%AF%95/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="redis单线程模型"></p><h4 id="redis有哪些数据类型？分别在哪些场景下比较合适？"><a href="#redis有哪些数据类型？分别在哪些场景下比较合适？" class="headerlink" title="redis有哪些数据类型？分别在哪些场景下比较合适？"></a>redis有哪些数据类型？分别在哪些场景下比较合适？</h4><ul><li>string<ul><li>就是普通的set和get,做简单的kv缓存</li></ul></li><li>hashMap<ul><li>类似map结构，这个一般用于结构化的数据（前提是没有嵌套），方便修改其中的一个字段</li><li>例如只修改用户的年龄</li></ul></li><li>list<ul><li>有序列表，一类数据的集合，常用于取集合中的部分数据</li><li>例如存储粉丝列表、评论列表，然后基于list实现分页查询；可以搞一个简单的消息队列，从list头怼进去，从list尾巴那里取出来</li></ul></li><li>set<ul><li>无序集合，自动去重</li><li>去重的集合；交集、并集、差集；共同好友、共同关注的人</li></ul></li><li>sort set<ul><li>排序的set,写进去的时候给一个分数，自动根据分数排序</li><li>分数写入时间，按照时间排序；排行版（根据用户获得的分数）</li></ul></li></ul><h4 id="redis过期策略有哪些？手写一下lru的代码？"><a href="#redis过期策略有哪些？手写一下lru的代码？" class="headerlink" title="redis过期策略有哪些？手写一下lru的代码？"></a>redis过期策略有哪些？手写一下lru的代码？</h4><ol><li>设置过期时间<ul><li>定期删除<ul><li>redis默认每隔100ms就随机抽取一些设置了过期时间的key,检查是否过期，如果就删除</li></ul></li><li>惰性删除<ul><li>当你查询设置了过期时间key，redis会惰性的检查一下是否过期，如果过期则删除且不会返回任何结果</li></ul></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. volatile-lru 使用LRU算法删除一个键(只针对设置了过期时间的key</span><br><span class="line">2. allkeys-lru(最常用) 使用LRU算法删除一个键</span><br><span class="line">3. volatile-lfu 使用LFU算法删除一个键(只针对设置了过期时间的键)</span><br><span class="line">4. allkeys-lfu 使用LFU算法删除一个键</span><br><span class="line">5. volatile-random 随机删除一个键(只针对设置了过期时间的键)</span><br><span class="line">6. allkeys-random 随机删除一个键</span><br><span class="line">7. volatile-ttl 删除最早过期的一个键</span><br><span class="line">8. noeviction 不删除键，返回错误信息(redis默认选项)</span><br></pre></td></tr></table></figure><p>使用LinkedHashMap，将最近访问的放在头部，最老访问的放在尾部，当数据量大于指定的缓存个数时，就删除最老的数据</p><h4 id="redis主从复制的原理？"><a href="#redis主从复制的原理？" class="headerlink" title="redis主从复制的原理？"></a>redis主从复制的原理？</h4><p>当启动一个slave node的时候，它会发送一个PSYNC命令给master node</p><p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave node部分缺少的数据；否则如果是slave node第一次连接master node<br>那么会触发一次full resynchronization,开始 full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将<br>从客户端收到的所有写命令缓存到内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到<br>内存中，然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据</p><p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个RDB save操作，<br>用一份数据给所有slave node</p><h5 id="主从复制的断点续传？"><a href="#主从复制的断点续传？" class="headerlink" title="主从复制的断点续传？"></a>主从复制的断点续传？</h5><p>从redis 2.8开始，就支持主从复制的断点续传；如果主从复制的过程中网络断掉，可以接着上次复制的地方继续复制下去，而不是从头开始复制。</p><p>master node会在内存中维护的一个blacklog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在blacklog中的。<br>如果master和slave网络连接断掉，slave会让master从上次的replica offset开始继续复制</p><p>但如果没有找到对应的offset，那么就会执行一次full resynchronization</p><h5 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h5><p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落磁盘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要使用缓存？&quot;&gt;&lt;a href=&quot;#为什么要使用缓存？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用缓存？&quot;&gt;&lt;/a&gt;为什么要使用缓存？&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;高性能&lt;ul&gt;
&lt;li&gt;同一条数据多次查询，第二次查询用缓存耗时缩短&lt;/
      
    
    </summary>
    
      <category term="专栏" scheme="https://xiebiao123.github.io/categories/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="缓存" scheme="https://xiebiao123.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="https://xiebiao123.github.io/2021/01/05/%E9%9D%A2%E8%AF%95%E4%B8%93%E6%A0%8F/zookeeper/"/>
    <id>https://xiebiao123.github.io/2021/01/05/面试专栏/zookeeper/</id>
    <published>2021-01-04T16:00:00.000Z</published>
    <updated>2022-01-11T09:21:19.693Z</updated>
    
    <content type="html"><![CDATA[<h4 id="说一说zookeeper有哪些使用场景？"><a href="#说一说zookeeper有哪些使用场景？" class="headerlink" title="说一说zookeeper有哪些使用场景？"></a>说一说zookeeper有哪些使用场景？</h4><ul><li>1.分布式协调</li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83.png" alt="分布式系统顺序性"></p><ul><li>2.分布式锁</li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" alt="分布式系统顺序性"></p><ul><li>3.元素据、配置信息管理</li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/zookeeper-%E5%85%83%E7%B4%A0%E6%8D%AE%E3%80%81%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86.png" alt="分布式系统顺序性"></p><ul><li>4.HA高可用性(主备切换)</li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/zookeeper-HA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7.png" alt="分布式系统顺序性"></p><h4 id="redis分布式锁-和-ZK分布式锁的对比-？"><a href="#redis分布式锁-和-ZK分布式锁的对比-？" class="headerlink" title="redis分布式锁 和 ZK分布式锁的对比 ？"></a>redis分布式锁 和 ZK分布式锁的对比 ？</h4><ol><li>redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能；zk分布式锁，获取不到锁，<strong>注册一个监听器</strong>即可，不需要不断主动尝试获取锁，性能开销较小</li><li>redis获取锁的那个客户端如果bug了或挂掉，那么只能等待超时时间之后才能释放；而ZK因为创建的是临时节点，只要客户端挂了，znode就没有了，此时自动释放锁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;说一说zookeeper有哪些使用场景？&quot;&gt;&lt;a href=&quot;#说一说zookeeper有哪些使用场景？&quot; class=&quot;headerlink&quot; title=&quot;说一说zookeeper有哪些使用场景？&quot;&gt;&lt;/a&gt;说一说zookeeper有哪些使用场景？&lt;/h4&gt;&lt;
      
    
    </summary>
    
      <category term="专栏" scheme="https://xiebiao123.github.io/categories/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="zookeeper" scheme="https://xiebiao123.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="https://xiebiao123.github.io/2021/01/05/%E9%9D%A2%E8%AF%95%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>https://xiebiao123.github.io/2021/01/05/面试专栏/分布式/</id>
    <published>2021-01-04T16:00:00.000Z</published>
    <updated>2022-01-26T01:34:46.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h4><h4 id="怎么解决分布式事务？"><a href="#怎么解决分布式事务？" class="headerlink" title="怎么解决分布式事务？"></a>怎么解决分布式事务？</h4><ul><li>两阶段提交方案 / XA方案</li></ul><p>两阶段提交有一个事务管理器的概念，负责协调多个数据源的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok<br>,那么就正事提交事务，在各个数据库上执行操作，如果任何一个数据库回答不ok，那么就回滚事务</p><p>这种分布式事务方案，比较适合单块应用里面，跨多个数据库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低<br>绝对不适合高并发的场景。可以通过Spring + JTA来实现</p><ul><li>TCC方案 （Try + Confirm + Cancel）<ul><li>Try阶段：这个阶段说的就是对各个服务的资源做检测以及对资源进行锁定或者预留</li><li>Confirm阶段： 这个阶段就是在各个服务中执行实际的操作</li><li>Cancel阶段： 如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功业务逻辑的回滚操作</li></ul></li></ul><p>除非你的系统对一致性要求非常高，是你系统中核心中的核心场景，并且最好各个业务的执行时间较短。比如常见的就是资金类的场景，那就可以用TCC方案。<br>自己编写大量的业务逻辑，自己判断一个事务中的各个环节是否ok，不ok就执行回滚代码</p><p>这种方案几乎很少人使用，因为这个事务回滚实际严重依赖于你写的代码来回滚和补偿，会造成补偿代码巨大，非常恶心</p><ul><li>本地消息表<ol><li>A系统在自己本地一个事务里面操作，同时插入一条数据到消息表里面</li><li>接着A系统将这个消息发送到MQ中去</li><li>B系统接收到消息之后，在一个事务里，往自己本地消息表里面插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了那么这个事务会回滚，这样保证消息不会重复处理</li><li>B系统执行成功之后，就会更新自己本地消息表的状态，以及A系统消息表的状态</li><li>如果B系统处理失败了，那么就不会更新消息表的状态，那么此时A系统会定时扫描自己的消息表，如果有没有处理的消息，会再次发送到MQ中去，让B再次处理</li><li>这个方案保证了最终的一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止</li></ol></li></ul><p>这个方案说实话最大的问题在于严重依赖于数据库的消息表来管理事务，这就导致高并发的场景下有性能瓶颈。怎么拓展？所以一般很少使用</p><p><img src="/images/%E9%9D%A2%E8%AF%95/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" alt="分布式事务-本地消息表"></p><ul><li>可靠消息最终一致性方案 (基于RacketMQ事务消息)<ol><li>A系统先发一个prepared消息到MQ,如果这个prepared消息发送失败，那么直接取消操作</li><li>如果这个消息发送成了，那么接着执行一个本地事务，如果成功就告诉MQ发送确认消息，如果失败就告诉MQ发送回滚消息</li><li>如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地事务</li><li>MQ会自动定时轮询所有prepared消息回调你的接口，问你这个消息是不是本地事务处理失败了，所以没有发送确认消息？那是继续重试还是回滚？一般来说这里我们就可以查询下数据库，之前本地事务是否执行了，如果回滚了那么这里也回滚吧。<br>这样可以避免本地事务执行成功了，确认消息发送失败</li><li>这个方案里，要是系统B的事务处理失败怎么办？重试，自动不断重试直到成功，如果实在是不行，那么就要针对重要的资金业务进行回滚。比如B系统本地回滚以后，想办法通知系统A也回滚；或者发送报警由人工来回滚或者补偿</li></ol></li></ul><p>这个还是比较合适的，目前国内互联网公司大都是这么玩的。要不你举用RocketMQ支持的</p><p><img src="/images/%E9%9D%A2%E8%AF%95/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="分布式事务-可靠消息最终一致性"></p><ul><li>最大努力通知方案<ol><li>系统A本地事务执行完之后，发送个消息到MQ中</li><li>这里会有一个专门消费MQ的最大努力通知服务，这个服务会消费MQ，然后写入数据库中记录下来或者放入一个内存队列中，接着调用系统B的接口</li><li>要是系统B执行成功就ok了；要是系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B。反复N次，最后还是不行就放弃</li></ol></li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5.png" alt="分布式事务-最大努力通知"></p><p>如果是一个资金严格要求决定不能出错的场景，你可以说你用的TCC方案，如果是一般的分布式场景，如订单插入之后要更新库存，库存数据没有资金那么敏感<br>可以用可靠消息最终一致性方案</p><blockquote><p>注意：rocketMQ 3.2.6之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变</p></blockquote><h4 id="如何设计一个高并发的系统架构？"><a href="#如何设计一个高并发的系统架构？" class="headerlink" title="如何设计一个高并发的系统架构？"></a>如何设计一个高并发的系统架构？</h4><ol><li>系统拆分<ul><li>将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多了数据库，也可以支持高并发</li></ul></li><li>缓存（高并发读 必须用）<ul><li>大部分的高并发请求，都是读多写少，所以完全可以数据库和缓存各写一份，然后读的时候大量走缓存redis，毕竟redis单机就可以支持几万的并发</li></ul></li><li>MQ （高并发写 必须用）<ul><li>把大量的写请求灌入MQ中，后面系统慢慢消费慢慢写，控制在mysql的承受范围内就可以了</li></ul></li><li>Elasticsearch （可以考虑用）<ul><li>es 是分布式的，可以随便扩容，分布式天然就可以支持高并发，因为动不动就可以扩容机器来抗更高的并发。那么一些简单的查询、统计类的操作，可以用es来承载，特别是全文检索类的操作</li></ul></li><li>分库分表<ul><li>可能到最后数据库层面还是免不了抗高并发的要求。这样我们可以将数据库拆分为多个库，多个库来抗更高的并发；如果一个表的数据量过大，我们还可以将一个表拆分成多个表，每个表的数据量保持少一点，提高sql的性能</li></ul></li><li>读写分离<ul><li>如果说大部分请求必须要落库，且读多写少，我们可以搞主从架构，主库写入，从库读取。当流量太多的时候，还可以加更多的从库</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是分布式事务？&quot;&gt;&lt;a href=&quot;#什么是分布式事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式事务？&quot;&gt;&lt;/a&gt;什么是分布式事务？&lt;/h4&gt;&lt;h4 id=&quot;怎么解决分布式事务？&quot;&gt;&lt;a href=&quot;#怎么解决分布式事务？&quot; cla
      
    
    </summary>
    
      <category term="专栏" scheme="https://xiebiao123.github.io/categories/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="分布式" scheme="https://xiebiao123.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>dubbo</title>
    <link href="https://xiebiao123.github.io/2021/01/05/%E9%9D%A2%E8%AF%95%E4%B8%93%E6%A0%8F/dubbo/"/>
    <id>https://xiebiao123.github.io/2021/01/05/面试专栏/dubbo/</id>
    <published>2021-01-04T16:00:00.000Z</published>
    <updated>2022-01-11T09:21:28.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要把系统拆成分布式的？为啥要用dubbo？"><a href="#为什么要把系统拆成分布式的？为啥要用dubbo？" class="headerlink" title="为什么要把系统拆成分布式的？为啥要用dubbo？"></a>为什么要把系统拆成分布式的？为啥要用dubbo？</h4><ul><li>可维护性低</li><li>耦合性高</li></ul><h4 id="dubbo的工作原理是啥？注册中心挂了可以继续通信吗？"><a href="#dubbo的工作原理是啥？注册中心挂了可以继续通信吗？" class="headerlink" title="dubbo的工作原理是啥？注册中心挂了可以继续通信吗？"></a>dubbo的工作原理是啥？注册中心挂了可以继续通信吗？</h4><ul><li>dubbo十层架构</li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/dubbo%E5%8D%81%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="dubbo十层架构"></p><ul><li>dubbo工作流程</li></ul><p><img src="/images/%E9%9D%A2%E8%AF%95/dubbo%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="dubbo工作流程"></p><h4 id="dubbo支持哪些通信协议？哪些序列化？"><a href="#dubbo支持哪些通信协议？哪些序列化？" class="headerlink" title="dubbo支持哪些通信协议？哪些序列化？"></a>dubbo支持哪些通信协议？哪些序列化？</h4><ul><li>dubbo支持通讯协议<ul><li>dubbo协议（默认）<ul><li>单一长连接，NIO异步通信，基于hessian作为序列化协议。适用的场景就是传输数据量很小（每次请求在100kb以内），但是并发很高</li><li>为了支持高并发场景，一般是服务提供者就几台机器，但是服务消费者就有上百台，可能每天调用量达到上亿次！此时用长连接是最适合的，就是跟每个服务消费者维持一个长连接就可以，可能总共就100个连接。然后后面直接基于长连接NIO异步通信，可以支持高并发请求。否则上亿次请求每次都是短连接的话，服务提供者会扛不住。而且因为走的是单一长连接，所以传输数据量太大的话，会导致并发能力降低，所以一般建议是传输数据量很小，支持高并发访问</li></ul></li><li>rmi协议<ul><li>走java二进制系列化，多个短连接，适合消费者和提供者数量差不多，适用于文件的传输，一般很少使用</li></ul></li><li>hessian协议<ul><li>走hessian序列化协议，多个短连接，适合提供者数量比消费者数量还多，适合文件的传输，一般很少使用</li></ul></li><li>http协议<ul><li>走json序列化</li></ul></li><li>webservice<ul><li>走SOAP文本序列化</li></ul></li></ul></li><li>dubbo支持序列化<ul><li>hessian序列化（默认）</li><li>java二进制系列化</li><li>json序列化</li><li>SOAP文本序列化</li></ul></li></ul><h4 id="dubbo负载均衡策略？"><a href="#dubbo负载均衡策略？" class="headerlink" title="dubbo负载均衡策略？"></a>dubbo负载均衡策略？</h4><ul><li>random loadbalance (默认)<ul><li>dubbo是随机调用实现负载均衡，可以对provider不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高</li></ul></li><li>roundrobin loadbalance<ul><li>这个就是均匀的将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些</li></ul></li><li>leastactive loadbalance<ul><li>这个就是自动感知一下，如果某个机器性能差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求</li></ul></li><li>consistanthash loadbalance<ul><li>一致性Hash算法，相同参数的请求一定分发到一个provider上去，provider挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会很大</li></ul></li></ul><h4 id="dubbo集群容错策略？"><a href="#dubbo集群容错策略？" class="headerlink" title="dubbo集群容错策略？"></a>dubbo集群容错策略？</h4><ul><li>failover cluster模式（默认）<ul><li>失败自动切换，自动重试其他机器，常见于读操作</li></ul></li><li>failfast cluster模式<ul><li>一次调用失败就立即失败，常见于写操作</li></ul></li><li>failsafe cluster模式<ul><li>出现异常时忽略掉，常用于不重要的接口调用，比如记录日志</li></ul></li><li>failbackc cluster模式<ul><li>失败了后台自动记录请求，然后定时重发，比较适合于写消息队列</li></ul></li><li>forking cluster模式<ul><li>并行调用多个provider，只要有一个成功就立即返回</li></ul></li></ul><h4 id="dubbo动态代理策略？"><a href="#dubbo动态代理策略？" class="headerlink" title="dubbo动态代理策略？"></a>dubbo动态代理策略？</h4><p>默认使用javassist动态字节码生成，创建代理类。但是可以通过spi拓展机制配置自己的动态策略</p><h4 id="SPI是啥思想？-dubbo-SPI机制是怎么玩的？"><a href="#SPI是啥思想？-dubbo-SPI机制是怎么玩的？" class="headerlink" title="SPI是啥思想？ dubbo SPI机制是怎么玩的？"></a>SPI是啥思想？ dubbo SPI机制是怎么玩的？</h4><p>SPI (service provider interface),简单来说SPI就是你有个接口，现在这个接口有三个实现类，那么系统在运行的时候对这个接口到底选择<br>那个实现类？这就需要SPI，需要根据指定的配置或者默认的配置，去找到对应的实现类加载进去，然后用这个实现类的实例对象</p><p>比如说你要通过jar包的方式给某个接口提供实现，然后你就在自己的jar包的 MERA-INFO/service/目录下放一个跟接口同名的文件，里面<br>指定接口的实现类是自己jar包里面的某个类，当别人用了这个接口并且用了你的jar包，就会在运行的时候通过你的jar包的那个文件找到<br>这个接口的实现类。</p><p>dubbo也用了SPI的思想，不过没有用JDK的SPI机制，是自己实现的一套SPI，dubbo微内核，大量可插拔的组件就是通过SPI实现的</p><h4 id="dubbo如何做服务治理、服务降级以及重试？"><a href="#dubbo如何做服务治理、服务降级以及重试？" class="headerlink" title="dubbo如何做服务治理、服务降级以及重试？"></a>dubbo如何做服务治理、服务降级以及重试？</h4><h5 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h5><ul><li>服务访问链路<ul><li>自动生成服务调用链路图</li></ul></li><li>服务访问压力以及时长的统计<ul><li>自动统计各个接口和服务之间的调用次数以及访问延时，而且要分成两个级别<ul><li>接口粒度，就是每个服务的每个接口，每天被调用多少次，以及每个接口的调用耗时</li><li>请求的完整链路，每天全链路走多少次，全链路的请求耗时</li></ul></li></ul></li><li>其他<ul><li>服务分层（避免循环依赖）</li><li>调用链路失败监控和报警</li><li>服务鉴权</li><li>每个服务的可用性监控（接口调用成功率？几个9？）</li></ul></li></ul><h5 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h5><p>基于mock</p><h5 id="接口重试"><a href="#接口重试" class="headerlink" title="接口重试"></a>接口重试</h5><p>retries + timeout</p><h4 id="分布式系统如何保证接口的幂等性"><a href="#分布式系统如何保证接口的幂等性" class="headerlink" title="分布式系统如何保证接口的幂等性?"></a>分布式系统如何保证接口的幂等性?</h4><ol><li>对于每个请求必须有一个唯一的标识<ul><li>例如订单支付请求里面的订单id</li></ul></li><li>每次处理完请求之后，必须有一个记录标识这个请求处理过了</li><li>每次接收到请求，需要先判断之前是否处理过</li></ol><h4 id="分布式系统如何保证接口的顺序性？"><a href="#分布式系统如何保证接口的顺序性？" class="headerlink" title="分布式系统如何保证接口的顺序性？"></a>分布式系统如何保证接口的顺序性？</h4><p><img src="/images/%E9%9D%A2%E8%AF%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E6%80%A7.png" alt="分布式系统顺序性"></p><h4 id="如何设计一个dubbo的rpc框架？"><a href="#如何设计一个dubbo的rpc框架？" class="headerlink" title="如何设计一个dubbo的rpc框架？"></a>如何设计一个dubbo的rpc框架？</h4><ol><li>首先需要一个注册中心，保留各个服务的信息，可以用zookeeper来做</li><li>然后消费者需要去注册中心拿到服务提供者的信息，而且每个服务可能会存在于多台机器上</li><li>接着你就该发起一次请求了，咋发起？当然是基于动态代理，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理<br>，然后这个代理会找到服务对应的机器地址</li><li>然后找那个机器发送请求？肯定需要一个负载均衡的算法，比如最简单的可以随机轮询，hash分配</li><li>找到机器以后就可以发送请求了，第一个问题咋发送？你可以说netty , nio方式；第二个问题发送啥数据格式？你可以说用hessian序列化协议</li><li>服务提供者这边一样，需要针对自己的服务生成一个动态代理，监听某个网络端口的，然后代理你本地的服务代码。接收到请求的时候<br>就调用对应的服务代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要把系统拆成分布式的？为啥要用dubbo？&quot;&gt;&lt;a href=&quot;#为什么要把系统拆成分布式的？为啥要用dubbo？&quot; class=&quot;headerlink&quot; title=&quot;为什么要把系统拆成分布式的？为啥要用dubbo？&quot;&gt;&lt;/a&gt;为什么要把系统拆成分布式的？
      
    
    </summary>
    
      <category term="专栏" scheme="https://xiebiao123.github.io/categories/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="dubbo" scheme="https://xiebiao123.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎多连炮</title>
    <link href="https://xiebiao123.github.io/2020/12/28/%E9%9D%A2%E8%AF%95%E4%B8%93%E6%A0%8F/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    <id>https://xiebiao123.github.io/2020/12/28/面试专栏/搜索引擎/</id>
    <published>2020-12-27T16:00:00.000Z</published>
    <updated>2022-01-11T09:21:45.511Z</updated>
    
    <content type="html"><![CDATA[<h4 id="es分布式架构的原理？"><a href="#es分布式架构的原理？" class="headerlink" title="es分布式架构的原理？"></a>es分布式架构的原理？</h4><p>es 设计的概念就是分布式搜索引擎，底层其实还是基于Lucene的</p><p>核心的思想就是在多台机器上启动多个es进程实例，组成了一个es集群。es中存储数据的基本单位是索引，这个索引可以拆分出多个shard<br>每个shard存储部分数据 。index -&gt; type -&gt; mapping -&gt; document -&gt; field</p><p>shard 又分为 primary shard 和 replica shard 并且分不到集群中的不同机器中 。 数据只能写入primary shard ，然后primary shard<br>再将数据同步到replica shard上去， es客户端获取数据既可以从primary shard 又可以从 replica shard 读</p><p><img src="/images/%E9%9D%A2%E8%AF%95/es%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png" alt="es读写数据原理"></p><h4 id="es写入数据的工作原理？"><a href="#es写入数据的工作原理？" class="headerlink" title="es写入数据的工作原理？"></a>es写入数据的工作原理？</h4><ol><li>客户端选择一个node发送请求过去，这个node就是协调节点（coordinating node）</li><li>协调节点对document进行路由(根据docId hash)，将请求转发给对应的node(有primary shard)</li><li>实际上是由node的 primary shard 处理请求，然后将数据同步到其他node(有replica shard)</li><li>协调节点发现primary shard 和 所有 replica node都搞定之后，就返回响应结果给客户端</li></ol><blockquote><p>数据如何写入磁盘：</p></blockquote><ol><li>primary shard 先将数据写入buffer（在buffer里面的数据是搜索不到的），同时将数据写入translog日志文件</li><li>如果buffer快写满了或者到了一定的时间（默认1秒），就会将buffer数据<strong>refresh</strong>到os cache中（在os cache中的数据可以被搜索到）<ul><li><strong>es是准实时的</strong>，写入的数据1秒以后才能被看到，可以调用es API手动<strong>refresh</strong>，将buffer中的数据刷入os cache中，让数据可以立马被搜索到</li></ul></li><li>当translog不断变大，达到一定阈值就会触发<strong>flush/commit</strong>操作<ul><li>primary shard 写入一个commit point到磁盘文件，里面标识了这个commit point对应的所有segment file</li><li>强行将os cache中目前所有的数据都fsync 到磁盘中去</li><li>将现有的translog清空，然后重新启用一个translog，此时commit操作完成<ul><li>默认每隔30分钟会自动执行一次flush，我们也可以调用es API手动flush</li></ul></li></ul></li><li>translog其实也是先写入os cache的，每隔5秒刷一次到磁盘中去<ul><li>最多丢失5秒的数据，可以设置成每次写操作必须直接fsync到磁盘，但是性能较差</li></ul></li></ol><h4 id="es读取数据的工作原理？"><a href="#es读取数据的工作原理？" class="headerlink" title="es读取数据的工作原理？"></a>es读取数据的工作原理？</h4><ol><li>客户端发送请求到任意一个node, 成为协调节点</li><li>协调节点对document进行路由，将请求转发到对应的node,此时会使用round-robin(随机轮询算法)，在primary shard以及所有replica<br>shard 中随机选择一个，让读请求做负载均衡</li><li>接收到请求的node返回document给协调节点</li><li>协调节点返回document给客户端</li></ol><h4 id="es搜索数据的过程？"><a href="#es搜索数据的过程？" class="headerlink" title="es搜索数据的过程？"></a>es搜索数据的过程？</h4><ol><li>客户端发送请求到一个协调节点</li><li>协调节点将请求转发到所有的shard（primary或replica）</li><li>每个shard将自己的搜索结果（其实就是一些docId）， 返回给协调节点，然后由协调节点进行数据的合并、排序、分页等操作</li><li>最后协调节点根据docId去各个节点上去拉取实际的document数据返回给客户端</li></ol><h4 id="es数据量很大的情况（数10亿级别），如何提高查询效率？"><a href="#es数据量很大的情况（数10亿级别），如何提高查询效率？" class="headerlink" title="es数据量很大的情况（数10亿级别），如何提高查询效率？"></a>es数据量很大的情况（数10亿级别），如何提高查询效率？</h4><ol><li>性能优化的杀手锏 – filesystem cache<ul><li>es设计时只存储需要搜索的字段</li><li>es + hbase / mysql</li></ul></li><li>数据预热<ul><li>定时任务手动搜索热点数据</li></ul></li><li>冷热分离<ul><li>将热点数据和冷数据分索引存储</li></ul></li><li>document模型设计<ul><li>涉及多表提前关联好需要查询的字段</li></ul></li><li>es分页<ul><li>不允许深度搜索，默认深度分页性能很差</li><li>用scroll api ，顺序分页，类似于微博一页页的拉取，不允许跨页<ul><li>scroll会一次性给你生成所有数据的一个快照，然后每次翻页就是通过游标移动，获取下一页数据</li></ul></li></ul></li></ol><h4 id="es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少分片？"><a href="#es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少分片？" class="headerlink" title="es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少分片？"></a>es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少分片？</h4><ol><li>es生产集群我们部署了5台机器，每台机器是6核64G的，集群总内存是320G</li><li>我们es集群的日增数据量大概是2000万条，每天日增数据量大概是500MB,每月增量数据大概是6亿/15G。目前系统已经运行了几个月<br>，现在es集群里数据总量大概是100G左右</li><li>目前线上有5个索引（这个结合业务来），每个索引的数据量大概是20G,所以这个数据量之内，我们索引分配的是8个shard,比默认的5个shard<br>多了3个shard</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;es分布式架构的原理？&quot;&gt;&lt;a href=&quot;#es分布式架构的原理？&quot; class=&quot;headerlink&quot; title=&quot;es分布式架构的原理？&quot;&gt;&lt;/a&gt;es分布式架构的原理？&lt;/h4&gt;&lt;p&gt;es 设计的概念就是分布式搜索引擎，底层其实还是基于Lucene的&lt;
      
    
    </summary>
    
      <category term="专栏" scheme="https://xiebiao123.github.io/categories/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="搜索引擎" scheme="https://xiebiao123.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>消息队列多连炮</title>
    <link href="https://xiebiao123.github.io/2020/12/16/%E9%9D%A2%E8%AF%95%E4%B8%93%E6%A0%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://xiebiao123.github.io/2020/12/16/面试专栏/消息队列/</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2022-01-11T09:21:40.035Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h4><ul><li>解耦</li><li>异步</li><li>消峰</li></ul><h4 id="消息队列有什么优点和缺点？"><a href="#消息队列有什么优点和缺点？" class="headerlink" title="消息队列有什么优点和缺点？"></a>消息队列有什么优点和缺点？</h4><ul><li>系统可用性降低</li><li>系统复杂性变高</li><li>一致性问题</li></ul><h4 id="kafka、activemq、rabbitmq、rocketmq-都有什么区别以及适合的场景？"><a href="#kafka、activemq、rabbitmq、rocketmq-都有什么区别以及适合的场景？" class="headerlink" title="kafka、activemq、rabbitmq、rocketmq 都有什么区别以及适合的场景？"></a>kafka、activemq、rabbitmq、rocketmq 都有什么区别以及适合的场景？</h4><table><thead><tr><th>特性</th><th align="center">ActiveMQ</th><th align="center">RabbitMQ</th><th align="center">RocketMQ</th><th align="center">Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td align="center">万级</td><td align="center">万级</td><td align="center">10 万级，支撑高吞吐</td><td align="center">10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td align="center"></td><td align="center"></td><td align="center">topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td align="center">topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td align="center">ms 级</td><td align="center">微秒级，延迟最低</td><td align="center">ms 级</td><td align="center">ms 级</td></tr><tr><td>可用性</td><td align="center">高，基于主从架构实现高可用</td><td align="center">同 ActiveMQ</td><td align="center">非常高，分布式架构</td><td align="center">非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td align="center">有较低的概率丢失数据</td><td align="center">基本不丢</td><td align="center">经过参数优化配置，可以做到 0 丢失</td><td align="center">同 RocketMQ</td></tr><tr><td>功能支持</td><td align="center">MQ 领域的功能极其完备</td><td align="center">基于erlang 开发，并发能力很强，性能极好，延时很低</td><td align="center">MQ 功能较为完善，还是分布式的，扩展性好</td><td align="center">功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><blockquote><p>综上，各种对比之后，有如下建议：</p></blockquote><ol><li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li><li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li><li>不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li><li>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范</li></ol><h4 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h4><h5 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h5><ul><li>单机模式</li><li>普通集群模式（无高可用性）<ul><li>消费者每次随机连接一个实例，然后该实例从真正的数据节点拉取数据，有数据拉取的开销</li><li>固定连接那个 queue 所在实例消费数据，导致单实例性能瓶颈</li><li>不是分布式的</li></ul></li><li>镜像集群模式（高可用性）<ul><li>不是分布式的，每个节点都有这个queue的完整数据，如果queue的数据量很大，大到这个机器上的容量无法容纳就会有问题</li></ul></li></ul><h5 id="Kafka-的高可用架构"><a href="#Kafka-的高可用架构" class="headerlink" title="Kafka 的高可用架构"></a>Kafka 的高可用架构</h5><ul><li>分布式集群模式<ul><li>kafka 是由多个 broker 组成，每个 broker 是一个节点</li><li>创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上</li><li>每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本</li><li>所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower</li><li>leader 会负责把数据同步到所有 follower 上去，读/写的时候就直接读/写 leader 上的数据即可</li><li>如果某个 broker 宕机了并且 broker上面有某个 partition 的 leader，那么此时会从其他broker的 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可</li></ul></li></ul><p>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p>消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到</p><h4 id="如何解决消息的重复消费"><a href="#如何解决消息的重复消费" class="headerlink" title="如何解决消息的重复消费"></a>如何解决消息的重复消费</h4><p>主要结合业务来实现消息的幂等性</p><ul><li>数据的主键ID,不存在插入，存在则更新</li><li>用redis给消息标记，存在则不处理</li></ul><h4 id="如何保证消息的可靠性（如何处理消息丢失问题）"><a href="#如何保证消息的可靠性（如何处理消息丢失问题）" class="headerlink" title="如何保证消息的可靠性（如何处理消息丢失问题）"></a>如何保证消息的可靠性（如何处理消息丢失问题）</h4><h5 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ol><li>写消息的过程中消息都没有到rabbitMq，或者消息到rabbitMq但是人家内部出错没有保存下来<ul><li>事务模式 （同步）</li><li>confirm模式（回调方法确认消息接收成功）（异步）</li></ul></li><li>rabbitMq接收到消息之后暂存到自己的内存里，在消费之前出现故障、重启导致内存数据丢失<ul><li>将消息持久化到磁盘上（同时持久化queue 和消息的持久化）</li></ul></li><li>消费者消费到了消息，但是还没来及处理就挂掉了，rabbitMq以为这个消费者已经处理完了<ul><li>将autoAck关闭，如果消费者没处理完就宕机了，此时rabbitMq没有收到你的ack消息，就会将这条消息重新分配给其他的消费者处理</li></ul></li></ol><h5 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h5><ol><li>消费者消费到了消息，但是还没来及处理就挂掉了，kafak以为这个消费者已经处理完了<ul><li>关闭自动提交offset，此时有重复消费的问题，自己保证幂等性</li></ul></li><li>kafka 某个broker宕机，然后重新选举partition的leader，而之前的leader还没有来的及同步数据到follower中<ul><li>topic的 <strong>replication.factor</strong> 参数的值必须大于1，即每个partition至少有2个副本</li><li>kafka的服务端设置 min.insync.replicas 参数的值必须大于1，即要求一个leader至少感知到一个follower还跟自己保持联系</li><li>在producer端设置 acks=all，这个是要求每条数据必须写入所有replica之后，才能认为是写入成功</li><li>在producer端设置 retries=MAX(很大的一个值，无限重试的意思)，这个是要求一旦写入失败，重试写入的次数</li></ul></li></ol><h4 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h4><h5 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ol><li>一个queue，多个consumer消费速度不一样，导致消费顺序不一致<ul><li>拆分多个queue，每个queue对应一个consumer</li><li>一个queue对应一个consumer，然后内部用内存队列做排列，然后再分发给不同的worker来处理</li></ul></li></ol><h5 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h5><ol><li>一个topic,一个partition，一个consumer，内部多线程<ul><li>内部单线程消费，根据唯一标识hash 写入N个内存queue，然后N个线程分别消费一个内存queue即可</li></ul></li></ol><h4 id="有几百万消息持续积压几个小时怎么处理？"><a href="#有几百万消息持续积压几个小时怎么处理？" class="headerlink" title="有几百万消息持续积压几个小时怎么处理？"></a>有几百万消息持续积压几个小时怎么处理？</h4><ol><li>先修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停掉</li><li>新建一个topic，partition是原来的10倍，临时建立好原来10倍的queue数量</li><li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消耗之后不做耗时的处理，直接均匀的轮询写入建立好的10倍数量的queue</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时的queue的数据</li><li>这种做法就相当于是临时将queue资源和consumer资源扩大10倍，以正常的10速度消费数据</li><li>等快速消费完积压数据以后，恢复原来的部署架构，重新用原来的consumer机器来消费消息</li></ol><h4 id="如何解决消息队列的延时以及过期失效的问题？"><a href="#如何解决消息队列的延时以及过期失效的问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效的问题？"></a>如何解决消息队列的延时以及过期失效的问题？</h4><p>假设你用的是rabbitMq，刚好你设置了过期时间TTL,如果消息在queue中积压超过一定的时间就会被rabbitMq给清理掉，这个数据就没了</p><blockquote><p>这个时候就需要些一个临时的程序把丢失的数据查出来，然后重新的插入到mq里面去，然后执行业务代码补全数据</p></blockquote><h4 id="消息队列满了以后怎么处理？-就是MQ积压的快挂掉了"><a href="#消息队列满了以后怎么处理？-就是MQ积压的快挂掉了" class="headerlink" title="消息队列满了以后怎么处理？ 就是MQ积压的快挂掉了"></a>消息队列满了以后怎么处理？ 就是MQ积压的快挂掉了</h4><ul><li>数据不重要<ul><li>临时写程序快速消费消息，消费一个丢弃一个，然后到了晚上再补数据</li></ul></li><li>数据重要<ul><li>临时写程序快速写入另外一个消息队列，然后再增加10倍queue、consumer来消费数据</li></ul></li></ul><h4 id="如果让你来开发一个消息中间件，你会如何设计架构"><a href="#如果让你来开发一个消息中间件，你会如何设计架构" class="headerlink" title="如果让你来开发一个消息中间件，你会如何设计架构"></a>如果让你来开发一个消息中间件，你会如何设计架构</h4><ul><li><strong>首先这个mq要支持可伸缩性，即快速的扩容增加吞吐量和容量</strong><ul><li>参考kafka的设计理念，broker-&gt;topic-&gt;partition</li><li>每个partition在一个机器中就存放一部分数据</li><li>需要扩容的时候，就给topic增加partition，然后做数据迁移，增加机器就可以存放更多的数据，提高吞吐量</li></ul></li><li><strong>mq数据要落磁盘，避免重启丢、故障失数据</strong><ul><li>顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是kafka的思路</li></ul></li><li><strong>mq的可用性</strong><ul><li>kafka高可用机制，多副本-&gt;leader &amp; follower -&gt;broker  挂了重新选举leader即可对外服务</li></ul></li><li><strong>支持数据0丢失</strong><ul><li>参考kafka 零丢失配置方案</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么使用消息队列？&quot;&gt;&lt;a href=&quot;#为什么使用消息队列？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用消息队列？&quot;&gt;&lt;/a&gt;为什么使用消息队列？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;消峰&lt;/li&gt;

      
    
    </summary>
    
      <category term="专栏" scheme="https://xiebiao123.github.io/categories/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="消息队列" scheme="https://xiebiao123.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从模式、哨兵模式、集群模式</title>
    <link href="https://xiebiao123.github.io/2020/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E3%80%81%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://xiebiao123.github.io/2020/11/19/学习笔记/中间件/Redis/Redis-主从模式、哨兵模式、集群模式/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从模式主要是基于Redis的主从复制特性架构的通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。主要的特点如下：</p><ul><li>主从模式下，当某一节点损坏时，因为其会将数据备份到其它Redis实例上，这样做在很大程度上可以恢复丢失的数据</li><li>主从模式下，可以保证负载均衡</li><li>主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力</li><li>从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下<br>从以上，我们不难看出Redis在主从模式下，必须保证主节点不会宕机，一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis将丧失写的能力</li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式是redis高可用的实现方式之一，使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。</p><h4 id="哨兵们是怎么感知整个系统中的所有节点-主节点-从节点-哨兵节点-的"><a href="#哨兵们是怎么感知整个系统中的所有节点-主节点-从节点-哨兵节点-的" class="headerlink" title="哨兵们是怎么感知整个系统中的所有节点(主节点/从节点/哨兵节点)的"></a>哨兵们是怎么感知整个系统中的所有节点(主节点/从节点/哨兵节点)的</h4><ol><li>首先主节点的信息是配置在哨兵(Sentinel)的配置文件中</li><li>哨兵节点会和配置的主节点建立起两条连接 命令连接 和 订阅连接</li><li>哨兵会通过命令连接每10s发送一次INFO命令，通过INFO命令，主节点会返回自己的run_id和自己的从节点信息</li><li>哨兵会对这些从节点也建立两条连 接命令连接 和 订阅连接</li><li>哨兵通过命令连接向从节点发送INFO命令，获取到他的一些信息<ul><li>run_id</li><li>role</li><li>从服务器的复制偏移量 offset</li><li>其他</li></ul></li><li>因为哨兵对与集群中的其他节点(主从节点)当前都有两条连接，命令连接和订阅连接<ul><li>通过命令连接向服务器的_sentinel:hello频道发送一条消息，内容包括自己的ip端口、run_id、配置纪元(后续投票的时候会用到)等</li><li>通过订阅连接对服务器的_sentinel:hello频道做了监听，所以所有的向该频道发送的哨兵的消息都能被接受到</li><li>解析监听到的消息，进行分析提取，就可以知道还有那些别的哨兵服务节点也在监听这些主从节点了，更新结构体将这些哨兵节点记录下来</li><li>向观察到的其他的哨兵节点建立命令连接—-没有订阅连接</li></ul></li></ol><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>哨兵节点会每秒一次的频率向建立了命令连接的实例发送ping命令，如果在down-after-milliseconds毫秒内没有响应，包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为SRI_S_DOWN主观下线</p><h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当一个哨兵节点发现主节点处于主观下线的状态，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了，如果超过配置参数quorum个节点认为主观下线，则该哨兵节点就会将自己的维护的结构体中该主节点标记为SRI_O_DOWN客观下线</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">询问命令 SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;run_id&gt;</span><br><span class="line">* ip/port   当前认为下线的主节点的ip和端口</span><br><span class="line">* current_epoch     配置纪元</span><br><span class="line">* run_id    标识仅用于询问是否下线，有值表示该哨兵节点希望对方将自己设置为leader(询问时用*，选举时用run_id)</span><br></pre></td></tr></table></figure><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><p>在认为主节点客观下线的情况下,哨兵节点节点间会发起一次选举，命令还是上面的命令SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; <current_epoch> <run_id>,只是run_id这次会将从节点的run_id带进去，希望接受者将该节点设置为主节点。如果超过半数以上的节点返回将该节点标记为leader的情况下，会由该leader对故障进行迁移</run_id></current_epoch></p><h4 id="故障迁移"><a href="#故障迁移" class="headerlink" title="故障迁移"></a>故障迁移</h4><ol><li>在从节点中挑选出新的主节点<ul><li>通讯正常</li><li>优先级排序</li><li>优先级相同则选择offset最大的</li></ul></li><li>从节点执行 SLAVEOF no one 命令，关闭复制功能，将该节点设置成新的主节点</li><li>将其他的从节点设置成从新的主节点复制, SLAVEOF命令</li><li>将旧的主节点变成新的从节点</li></ol><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>官方提供的分布式方案（槽指派、重新分片、故障转移）</p><h4 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h4><p>redis集群可以被分为16384个槽，只有这些槽全被指派了处理的节点情况下，集群的状态才能是上线状态（ok）<br>操作redis集群的时候，将key作为参数，就可以计算出对应的处理槽上，所以存储等操作都应该在该槽对应的节点上。通过这种方式，可以完美的实现集群存储的水平拓展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def slot_number(key):</span><br><span class="line">  return CRC16(key) &amp; 16383</span><br><span class="line">//得到的结果就是槽的序号</span><br></pre></td></tr></table></figure><h4 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h4><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h5 id="发现故障节点"><a href="#发现故障节点" class="headerlink" title="发现故障节点"></a>发现故障节点</h5><ol><li>集群内的节点会向其他节点发送PING命令，检查是否在线</li><li>如果未能在规定时间内做出PONG响应，则会把对应的节点标记为疑似下线</li><li>集群中一半以上负责处理槽的主节点都将主节点X标记为疑似下线的话，那么这个主节点X就会被认为是已下线</li><li>向集群广播主节点X已下线,大家收到消息后都会把自己维护的结构体里的主节点X标记为已下线</li></ol><h5 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h5><ol><li>当从节点发现自己复制的主节点已下线了，会向集群里面广播一条消息，要求所有有投票权的节点给自己投票(所有负责处理槽的主节点都有投票权)</li><li>主节点会向第一个给他发选举消息的从节点回复支持</li><li>当支持数量超过N/2+1的情况下，该从节点当选新的主节点</li></ol><h5 id="故障迁移-1"><a href="#故障迁移-1" class="headerlink" title="故障迁移"></a>故障迁移</h5><ol><li>新当选的从节点执行 SLAVEOF no one,修改成主节点</li><li>新的主节点会撤销所有已下线的老的主节点的槽指派，指派给自己</li><li>新的主节点向集群发送命令，通知其他节点自己已经变成主节点了，负责哪些槽指派</li><li>新的主节点开始处理自己负责的槽的命令</li></ol><h3 id="集群模式和哨兵模式的区别"><a href="#集群模式和哨兵模式的区别" class="headerlink" title="集群模式和哨兵模式的区别"></a>集群模式和哨兵模式的区别</h3><ol><li>哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控</li><li>哨兵模式发起选举是选举一个leader哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主从模式&quot;&gt;&lt;a href=&quot;#主从模式&quot; class=&quot;headerlink&quot; title=&quot;主从模式&quot;&gt;&lt;/a&gt;主从模式&lt;/h3&gt;&lt;p&gt;主从模式主要是基于Redis的主从复制特性架构的通常我们会设置一个主节点，N个从节点;默认情况下，主节点负责处理使用者的IO
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="redis" scheme="https://xiebiao123.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>vagrant</title>
    <link href="https://xiebiao123.github.io/2020/11/16/%E5%B0%8F%E5%B7%A5%E5%85%B7/vagrant/"/>
    <id>https://xiebiao123.github.io/2020/11/16/小工具/vagrant/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.950Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="小工具" scheme="https://xiebiao123.github.io/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vagrant" scheme="https://xiebiao123.github.io/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Redis 过期时间</title>
    <link href="https://xiebiao123.github.io/2020/10/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
    <id>https://xiebiao123.github.io/2020/10/12/学习笔记/中间件/Redis/Redis-过期时间/</id>
    <published>2020-10-11T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.940Z</updated>
    
    <content type="html"><![CDATA[<h5 id="redis如何清理过期key"><a href="#redis如何清理过期key" class="headerlink" title="redis如何清理过期key"></a>redis如何清理过期key</h5><p>redis出于性能上的考虑，无法做到对每一个过期的key进行即时的过期监听和删除。但是redis提供了其它的方法来清理过期的key</p><ul><li><strong>被动清理</strong></li></ul><p>当用户主动访问一个过期的key时，redis会将其从内存中删除</p><ul><li><strong>主动清理</strong></li></ul><p>在redis的持久化中，我们知道redis为了保持系统的稳定性，健壮性，会周期性的执行一个函数。在这个过程中，会进行之前已经提到过的自动的持久化操作，同时也会进行内存的主动清理。</p><p>在内存主动清理的过程中，redis采用了一个随机算法来进行这个过程：简单来说，redis会随机的抽取N(默认100)个被设置了过期时间的key，检查这其中已经过期的key，将其清除。同时，如果这其中已经过期的key超过了一定的百分比M(默认是25)，则将继续执行一次主动清理，直至过期key的百分比在概率上降低到M以下</p><ul><li><strong>内存不足触发主动清理</strong></li></ul><p>在redis的内存不足时，也会触发主动清理。</p><h5 id="redis内存不足时候，清理key的策略"><a href="#redis内存不足时候，清理key的策略" class="headerlink" title="redis内存不足时候，清理key的策略"></a>redis内存不足时候，清理key的策略</h5><p>redis是一个基于内存的数据库，如果存储的数据量很大，达到了内存限制的最大值，将会出现内存不足的问题。redis允许用户通过配置maxmemory-policy参数，指定redis在内存不足时的解决策略，具体参数如下：</p><ol><li>volatile-lru 使用LRU算法删除一个键(只针对设置了过期时间的key</li><li><strong>allkeys-lru</strong> 使用LRU算法删除一个键</li><li>volatile-lfu 使用LFU算法删除一个键(只针对设置了过期时间的键)</li><li>allkeys-lfu 使用LFU算法删除一个键</li><li>volatile-random 随机删除一个键(只针对设置了过期时间的键)</li><li>allkeys-random 随机删除一个键</li><li>volatile-ttl 删除最早过期的一个键</li><li>noeviction 不删除键，返回错误信息(redis默认选项)</li></ol><blockquote><p>注意：</p><ul><li><strong>LRU</strong> 是最近最少使用置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的key</li><li><strong>LFU</strong> 是最近最不常用置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的key</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;redis如何清理过期key&quot;&gt;&lt;a href=&quot;#redis如何清理过期key&quot; class=&quot;headerlink&quot; title=&quot;redis如何清理过期key&quot;&gt;&lt;/a&gt;redis如何清理过期key&lt;/h5&gt;&lt;p&gt;redis出于性能上的考虑，无法做到对每一个
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="redis" scheme="https://xiebiao123.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot</title>
    <link href="https://xiebiao123.github.io/2020/07/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/SpringBoot/Springboot-sentinel-nacos/"/>
    <id>https://xiebiao123.github.io/2020/07/14/学习笔记/Spring/SpringBoot/Springboot-sentinel-nacos/</id>
    <published>2020-07-13T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>sentinel 原生版本的规则管理通过API，将规则推送至客户端并直接更新到内存中，服务重启自己定义的限流规则会丢失。如何避免这一问题？<br>这是我们想到了使用Nacos、Apollo等配置中心来持久话配置，客户端监听配置变化并更新本地缓存。即解决上述问题</p><h3 id="sentinel-控制台"><a href="#sentinel-控制台" class="headerlink" title="sentinel 控制台"></a>sentinel 控制台</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nacos.config.server-addr</span> <span class="string">=</span> <span class="string">localhost:8848</span></span><br><span class="line"><span class="string">nacos.config.namespace</span> <span class="string">=</span> <span class="string">a2881d2a-5c21-4f9e-9c75-dd93872e9ce8</span></span><br></pre></td></tr></table></figure><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><ul><li>AuthorityRuleController (授权规则)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">publishRules</span><span class="params">(String app, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">    List&lt;AuthorityRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span><br><span class="line">    <span class="comment">// 同步规则至nacos</span></span><br><span class="line">    sentinelNacosConsts.setAppName(app);</span><br><span class="line">    String rulesStr = JSON.toJSONString(rules);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = configService.publishConfig(sentinelNacosConsts.getAuthorityFileName(),sentinelNacosConsts.getGroupName(),rulesStr);</span><br><span class="line">        log.info(<span class="string">"发布规则：&#123;&#125;"</span>,result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.info(<span class="string">"发布规则异常：&#123;&#125;"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinelApiClient.setAuthorityRuleOfMachine(app, ip, port, rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DegradeController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">publishRules</span><span class="params">(String app, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">    List&lt;DegradeRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span><br><span class="line">    <span class="comment">// 同步规则至nacos</span></span><br><span class="line">    sentinelNacosConsts.setAppName(app);</span><br><span class="line">    String rulesStr = JSON.toJSONString(rules);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = configService.publishConfig(sentinelNacosConsts.getDegradeRuleFileName(),sentinelNacosConsts.getGroupName(),rulesStr);</span><br><span class="line">        log.info(<span class="string">"发布规则：&#123;&#125;"</span>,result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.info(<span class="string">"发布规则异常：&#123;&#125;"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinelApiClient.setDegradeRuleOfMachine(app, ip, port, rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FlowControllerV1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">publishRules</span><span class="params">(String app, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">    List&lt;FlowRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span><br><span class="line">    <span class="comment">// 同步规则至nacos</span></span><br><span class="line">    sentinelNacosConsts.setAppName(app);</span><br><span class="line">    String rulesStr = JSON.toJSONString(rules);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = configService.publishConfig(sentinelNacosConsts.getFlowRuleFileName(),sentinelNacosConsts.getGroupName(),rulesStr);</span><br><span class="line">        log.info(<span class="string">"发布规则：&#123;&#125;"</span>,result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.info(<span class="string">"发布规则异常：&#123;&#125;"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinelApiClient.setFlowRuleOfMachine(app, ip, port, rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ParamFlowRuleController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">publishRules</span><span class="params">(String app, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">    List&lt;ParamFlowRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span><br><span class="line">    <span class="comment">// 同步规则至nacos</span></span><br><span class="line">    sentinelNacosConsts.setAppName(app);</span><br><span class="line">    String rulesStr = JSON.toJSONString(rules);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = configService.publishConfig(sentinelNacosConsts.getParamFlowFileName(),sentinelNacosConsts.getGroupName(),rulesStr);</span><br><span class="line">        log.info(<span class="string">"发布规则：&#123;&#125;"</span>,result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.info(<span class="string">"发布规则异常：&#123;&#125;"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinelApiClient.setParamFlowRuleOfMachine(app, ip, port, rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SystemController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">publishRules</span><span class="params">(String app, String ip, Integer port)</span> </span>&#123;</span><br><span class="line">    List&lt;SystemRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span><br><span class="line">    <span class="comment">// 同步规则至nacos</span></span><br><span class="line">    sentinelNacosConsts.setAppName(app);</span><br><span class="line">    String rulesStr = JSON.toJSONString(rules);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = configService.publishConfig(sentinelNacosConsts.getSystemRuleFileName(),sentinelNacosConsts.getGroupName(),rulesStr);</span><br><span class="line">        log.info(<span class="string">"发布规则：&#123;&#125;"</span>,result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.info(<span class="string">"发布规则异常：&#123;&#125;"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sentinelApiClient.setSystemRuleOfMachine(app, ip, port, rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sentinel-客户端"><a href="#sentinel-客户端" class="headerlink" title="sentinel 客户端"></a>sentinel 客户端</h3><h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 接入sentinel、nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--dubbo和http监控限流--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-dubbo-adapter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--集群流控--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-cluster-client-default<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-cluster-server-default<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--传输数据给dashboard--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-netty-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos作为规则数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 热点参数限流 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-parameter-flow-control<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Reactor适配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-reactor-adapter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注解配置的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="指定配置-1"><a href="#指定配置-1" class="headerlink" title="指定配置"></a>指定配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nacos.config.server-addr</span> <span class="string">=</span> <span class="string">localhost:8848</span></span><br><span class="line"><span class="string">nacos.config.namespace</span> <span class="string">=</span> <span class="string">a2881d2a-5c21-4f9e-9c75-dd93872e9ce8</span></span><br><span class="line"><span class="string">spring.cloud.sentinel.transport.port</span> <span class="string">=</span> <span class="number">6719</span></span><br><span class="line"><span class="string">spring.cloud.sentinel.transport.dashboard</span> <span class="string">=</span> <span class="string">localhost:8088</span></span><br></pre></td></tr></table></figure><h4 id="监听配置、更新本地缓存"><a href="#监听配置、更新本地缓存" class="headerlink" title="监听配置、更新本地缓存"></a>监听配置、更新本地缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelNacosAutoReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NacosInjected</span></span><br><span class="line">    <span class="keyword">private</span> ConfigService configService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractListener flowRuleListen = <span class="keyword">new</span> AbstractListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;FlowRule&gt; rules = JSON.parseObject(configInfo, <span class="keyword">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    FlowRuleManager.loadRules(rules);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"FlowRule loadRules error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        AbstractListener degradeRuleLisener = <span class="keyword">new</span> AbstractListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;DegradeRule&gt; rules = JSON.parseObject(configInfo, <span class="keyword">new</span> TypeReference&lt;List&lt;DegradeRule&gt;&gt;() &#123;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    DegradeRuleManager.loadRules(rules);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"DegradeRule loadRules error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(configInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        AbstractListener systemRuleListener = <span class="keyword">new</span> AbstractListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;SystemRule&gt; rules = JSON.parseObject(configInfo, <span class="keyword">new</span> TypeReference&lt;List&lt;SystemRule&gt;&gt;() &#123;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    SystemRuleManager.loadRules(rules);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"SystemRule loadRules error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(configInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        AbstractListener paramFlowRuleListener = <span class="keyword">new</span> AbstractListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;ParamFlowRule&gt; rules = JSON.parseObject(configInfo, <span class="keyword">new</span> TypeReference&lt;List&lt;ParamFlowRule&gt;&gt;() &#123;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    ParamFlowRuleManager.loadRules(rules);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"ParamFlowRule loadRules error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(configInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        AbstractListener authorityRuleListener = <span class="keyword">new</span> AbstractListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;AuthorityRule&gt; rules = JSON.parseObject(configInfo, <span class="keyword">new</span> TypeReference&lt;List&lt;AuthorityRule&gt;&gt;() &#123;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    AuthorityRuleManager.loadRules(rules);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"AuthorityRule loadRules error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(configInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SentinelNacosConsts consts = <span class="keyword">new</span> SentinelNacosConsts();</span><br><span class="line">            configService.addListener(consts.getFlowRuleFileName(), consts.getGroupName(), flowRuleListen);</span><br><span class="line">            configService.addListener(consts.getDegradeRuleFileName(), consts.getGroupName(), degradeRuleLisener);</span><br><span class="line">            configService.addListener(consts.getSystemRuleFileName(), consts.getGroupName(), systemRuleListener);</span><br><span class="line">            configService.addListener(consts.getAuthorityFileName(), consts.getGroupName(), authorityRuleListener);</span><br><span class="line">            configService.addListener(consts.getParamFlowFileName(), consts.getGroupName(), paramFlowRuleListener);</span><br><span class="line">            log.info(<span class="string">"完成sentinel from nacos 配置的监听"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            log.error(<span class="string">"sentinel配置监听失败"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Sentinel 控制台 → 配置中心（nacos、apollo） → Sentinel 数据源(mysql) → Sentinel 客户端监听到配置中心的变化更新到本地缓存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;sentinel 原生版本的规则管理通过API，将规则推送至客户端并直接更新到内存中，服务重启自己定义的限流规则会丢失。如何避免这一问题？&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="nacos" scheme="https://xiebiao123.github.io/tags/nacos/"/>
    
      <category term="sentinel" scheme="https://xiebiao123.github.io/tags/sentinel/"/>
    
      <category term="Spring boot" scheme="https://xiebiao123.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Window</title>
    <link href="https://xiebiao123.github.io/2020/01/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Window/Window/"/>
    <id>https://xiebiao123.github.io/2020/01/14/学习笔记/Window/Window/</id>
    <published>2020-01-13T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows10关闭占用某一端口号的进程"><a href="#Windows10关闭占用某一端口号的进程" class="headerlink" title="Windows10关闭占用某一端口号的进程"></a><a href="https://blog.csdn.net/eagleuniversityeye/article/details/79985027" target="_blank" rel="noopener">Windows10关闭占用某一端口号的进程</a></h3><ul><li>查看端口的使用情况</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 8080(端口号)</span><br><span class="line"></span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       3732</span><br><span class="line">  TCP    10.204.254.11:49581    10.204.243.46:8080     ESTABLISHED     11624</span><br><span class="line">  TCP    10.204.254.11:55550    183.3.235.67:8080      ESTABLISHED     21528</span><br><span class="line">  TCP    10.204.254.11:63736    10.204.58.224:8080     ESTABLISHED     3732</span><br><span class="line">  TCP    10.204.254.11:65290    10.204.58.223:8080     ESTABLISHED     3732</span><br><span class="line">  TCP    [::]:8080              [::]:0                 LISTENING       3732</span><br></pre></td></tr></table></figure><ul><li>强制关闭指定进程号的进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskkill -PID 3732(进程号) -F</span><br><span class="line"></span><br><span class="line">成功: 已终止 PID 为 3732 的进程。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Windows10关闭占用某一端口号的进程&quot;&gt;&lt;a href=&quot;#Windows10关闭占用某一端口号的进程&quot; class=&quot;headerlink&quot; title=&quot;Windows10关闭占用某一端口号的进程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.c
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Window" scheme="https://xiebiao123.github.io/tags/Window/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务</title>
    <link href="https://xiebiao123.github.io/2020/01/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/Spring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://xiebiao123.github.io/2020/01/13/学习笔记/Spring/Spring事务/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>READ UNCOMMITTED (读未提交)</li><li>READ COMMITTED (读已提交)</li><li>REPEATABLE READ (可重复读)</li><li>SERIALIZABLE (串行化)</li></ul><h3 id="事务的隔离级别与脏读、不可重复度、幻读"><a href="#事务的隔离级别与脏读、不可重复度、幻读" class="headerlink" title="事务的隔离级别与脏读、不可重复度、幻读"></a>事务的隔离级别与脏读、不可重复度、幻读</h3><table><thead><tr><th align="center">事务隔离级别</th><th align="center">脏读</th><th align="center">不可重复度</th><th align="center">幻读</th><th align="center">默认</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">读已提交</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">Oracle</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">Mysql</td></tr><tr><td align="center">串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center"></td></tr></tbody></table><h4 id="Spring-5种事务隔离级别"><a href="#Spring-5种事务隔离级别" class="headerlink" title="Spring 5种事务隔离级别"></a>Spring 5种事务隔离级别</h4><ul><li><strong>ISOLATION_DEFAULT</strong> Spring将使用数据库中默认的事务隔离级别</li><li><strong>ISOLATION_READ_UNCOMMITTED</strong></li><li><strong>ISOLATION_READ_COMMITTED</strong></li><li><strong>ISOLATION_REPEATABLE_READ</strong></li><li><strong>ISOLATION_SERIALIZABLE</strong></li></ul><h4 id="Spring-7种事务传播机制"><a href="#Spring-7种事务传播机制" class="headerlink" title="Spring 7种事务传播机制"></a>Spring 7种事务传播机制</h4><ul><li>REQUIRED<ul><li>如果当前方法有事务则加入事务，没有则创建一个事务</li></ul></li><li>NOT_SUPPORTED<ul><li>不支持事务，如果当前有事务则挂起事务运行</li></ul></li><li>REQUIREDS_NEW<ul><li>新建一个事务并在这个事务中运行，如果当前存在事务就把当前事务挂起。新建的事务的提交与回滚与挂起事务没有联系，不会影响挂起事务的操作</li></ul></li><li>MANDATORY<ul><li>强制当前方法使用事务运行，如果当前没有事务则抛出异常</li></ul></li><li>NEVER<ul><li>当前方法不能存在事务，即非事务状态运行，如果存在事务则抛出异常</li></ul></li><li>SUPPORTS<ul><li>支持当前事务，如果当前没事务也支持非事务状态运行</li></ul></li><li>NESTED<ul><li>如果当前存在事务，则在嵌套事务内执行。嵌套事务的提交与回滚与父事务没有任何关系，反之，当父事务提交嵌套事务也一起提交，父事务回滚会也回滚嵌套事务的。如果当前没有事务，则新建一个事务运行，这时候则与PROPAGATION_REQUIRED场景一致</li></ul></li></ul><h3 id="Spring的-Transactional-注解控制事务失效场景"><a href="#Spring的-Transactional-注解控制事务失效场景" class="headerlink" title="Spring的@Transactional 注解控制事务失效场景"></a>Spring的@Transactional 注解控制事务失效场景</h3><ul><li>数据库引擎不支持事务<ul><li>MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎（MySQL 5.5.5 开始的默认存储引擎是：InnoDB）</li></ul></li><li>没有被Spring管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法不是public的<ul><li>@Transactional 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 AspectJ 代理模式</li></ul></li><li>自身调用问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个示例事务均失效，默认只有外部调用的事务才会生效，因为需要经过Spring的代理类</span></span><br></pre></td></tr></table></figure><ul><li>数据源没有配置事务管理器了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不支持事务<ul><li>Propagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        updateOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// update order</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常被吃掉</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// update order</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常的类型错误</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// update order</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"更新错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如: @Transactional(rollbackFor = Exception.class) 这个配置仅限于 Throwable 异常类及其子类</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务的隔离级别&quot;&gt;&lt;a href=&quot;#事务的隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务的隔离级别&quot;&gt;&lt;/a&gt;事务的隔离级别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED (读未提交)&lt;/li&gt;
&lt;li&gt;READ COMMIT
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring" scheme="https://xiebiao123.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>小程序</title>
    <link href="https://xiebiao123.github.io/2019/12/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/web%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://xiebiao123.github.io/2019/12/05/学习笔记/web前端/小程序/</id>
    <published>2019-12-04T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.946Z</updated>
    
    <content type="html"><![CDATA[<h3 id="catchtap-、-bindtap-、-longtap"><a href="#catchtap-、-bindtap-、-longtap" class="headerlink" title="catchtap 、 bindtap 、 longtap"></a>catchtap 、 bindtap 、 longtap</h3><ul><li>bindtap： 允许事件冒泡</li><li>catchtap： 阻止事件冒泡</li><li>longtap：手指触摸后，超过350ms再离开</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;catchtap-、-bindtap-、-longtap&quot;&gt;&lt;a href=&quot;#catchtap-、-bindtap-、-longtap&quot; class=&quot;headerlink&quot; title=&quot;catchtap 、 bindtap 、 longtap&quot;&gt;&lt;/a&gt;ca
      
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="小程序" scheme="https://xiebiao123.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql之分库分表</title>
    <link href="https://xiebiao123.github.io/2019/11/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://xiebiao123.github.io/2019/11/20/学习笔记/数据库/Mysql-分库分表/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2022-01-11T06:08:36.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h3><p>当流量不大的时候，单机数据库就够了。后面因为业务的发展请求越来越多，但是我们发现大多数都是读请求，于是我们想到了将数据库的<br><strong>写操作</strong>和<strong>读操作</strong>进行分离，使用多个从库（Slaver）副本负责读，使用主库（Master）负责写，主库的数据同步给从库保持数据的一致，从<br>库可以水平拓展，所以更多的读请求也不成问题</p><p>但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保持一致性，写操作需要2个master<br>之间同步，相当于是重复了，而且更加复杂。这时就需要用到<strong>分库分表</strong>，对写操作进行切分</p><a id="more"></a><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><ul><li>概念：以字段为依据，按照字段的活跃性，将表中字段拆分到不同的表（主表和拓展表）中</li><li>场景：系统并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。<br>以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.png" alt="垂直分表"></p><h5 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h5><ul><li>概念：以表为依据，按照业务归属不同，将不同表拆分到不同的库中</li><li>场景：系统并发量上来了，并且可以抽象出单独的业务模块</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93.png" alt="垂直分库"></p><h5 id="垂直切分优点、缺点"><a href="#垂直切分优点、缺点" class="headerlink" title="垂直切分优点、缺点"></a>垂直切分优点、缺点</h5><ul><li>优点<ul><li>解决业务系统层面的耦合，业务清晰</li><li>与微服务的治理类似，也能对不同业务的数据进行分级管理，维护，监控，扩展等</li><li>高并发场景下，垂直切分一定程度的提升IO，数据库连接数，单机硬件资源的瓶颈</li></ul></li><li>缺点<ul><li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li><li>分布式事务处理复杂</li><li>依然存在单表数据量过大的问题</li></ul></li></ul><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><h5 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h5><ul><li>概念：以字段为依据，按照一定的策略（hash、range等），将一个<strong>表</strong>中的数据拆分到多个<strong>表</strong>中</li><li>场景：系统并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.png" alt="水平分表"></p><h5 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h5><ul><li>概念：以字段为依据，按照一定的策略（hash、range等），将一个<strong>库</strong>中的数据拆分到多个<strong>库</strong>中</li><li>场景：系统并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93.png" alt="水平分库"></p><h5 id="水平切分优点、缺点"><a href="#水平切分优点、缺点" class="headerlink" title="水平切分优点、缺点"></a>水平切分优点、缺点</h5><ul><li>优点<ul><li>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li><li>应用端改造较小，不需要拆分业务模块  </li></ul></li><li>缺点<ul><li>跨分片的事务一致性难以保证</li><li>跨库的join关联查询性能较差</li><li>数据多次扩展维度和维护量极大</li></ul></li></ul><h5 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h5><ul><li>范围路由（range）<ul><li>概念：选取有序的数据列作为路由条件，不同分段分散到不同的数据库表中</li><li>优点：可以随着数据的增加平滑的扩充新表</li><li>缺点：可能存在数据库分布不均匀</li></ul></li><li>hash算法<ul><li>概念：选择某列（或几个列的组合）的值进行hash运算，然后根据运算结果分散到不同的数据库表中</li><li>优点：表数据分布比较均匀</li><li>缺点：初始表数据量不好选取，扩充新的表数据需要重新分布</li></ul></li><li>路由配置<ul><li>使用独立的表（或者配置文件等）记录路由配置信息</li><li>优点：使用起来简单灵活，扩充表时只需要迁移指定的数据，然后修改路由表</li><li>缺点：必须多查询一次，影响整体性能。<strong>路由表本事太多影响系统整体系统</strong></li></ul></li></ul><h3 id="分库分表组件-amp-中间件"><a href="#分库分表组件-amp-中间件" class="headerlink" title="分库分表组件&amp;中间件"></a>分库分表组件&amp;中间件</h3><p>简单易用的组件：</p><ul><li>当当sharding-jdbc</li><li>蘑菇街TSharding</li></ul><p>强悍重量级的中间件：</p><ul><li>TDDL Smart Client的方式（淘宝）</li><li>Atlas(Qihoo 360)</li><li>alibaba.cobar(是阿里巴巴（B2B）部门开发)</li><li>MyCAT（基于阿里开源的Cobar产品而研发）</li><li>Oceanus(58同城数据库中间件)</li><li>OneProxy(支付宝首席架构师楼方鑫开发)</li><li>vitess（谷歌开发的数据库中间件）</li></ul><h3 id="分库分表步骤"><a href="#分库分表步骤" class="headerlink" title="分库分表步骤"></a>分库分表步骤</h3><ol><li>根据容量（当前容量和增长量）评估分库或分表个数</li><li>选key（均匀），确定分表规则（hash或range等）</li><li>执行（一般选择双写），尽量减少数据的移动</li></ol><h3 id="分库分表常见问题"><a href="#分库分表常见问题" class="headerlink" title="分库分表常见问题"></a>分库分表常见问题</h3><h4 id="非分区key条件组合查询，数据报表统计"><a href="#非分区key条件组合查询，数据报表统计" class="headerlink" title="非分区key条件组合查询，数据报表统计"></a>非分区key条件组合查询，数据报表统计</h4><p>一般大型的系统都会有专门的后台管理系统，而管理系统的查询查询都是用非分区key组合条件查询，并且经常需要做报表来分析数据，这些需求对于分库分表的数据来说实现起来很复杂。此时我们就需要同步数据到es、Hbase等NoSQL数据库中，管理后台再对这部分数据操作即可<br><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.png" alt="数据同步"></p><h4 id="扩容问题"><a href="#扩容问题" class="headerlink" title="扩容问题"></a>扩容问题</h4><h5 id="水平扩容表"><a href="#水平扩容表" class="headerlink" title="水平扩容表"></a>水平扩容表</h5><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9%E8%A1%A8.png" alt="水平扩容表"></p><ul><li>应用配置之双写、重新部署</li><li>将老库中的旧数据复制到新库中</li><li>以老库为准校对新库中的老数据</li><li>应用去掉双写，重新部署</li></ul><h5 id="水平扩容库"><a href="#水平扩容库" class="headerlink" title="水平扩容库"></a>水平扩容库</h5><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%AE%B9%E5%BA%93.png" alt="水平扩容库"></p><ol><li>增加两个数据库连接，指向主库</li><li>修改数据库配置文件，由2个数据源变成4个</li><li>备库升级，并和第一步添加的数据连接关联</li><li>解除旧的主备同步，添加新的主备同步</li><li>删除冗余的数据</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>分库分表，首先得知道瓶颈在哪里，然后才能合理地拆分（分库还是分表？水平还是垂直？分几个？）。且不可为了分库分表而拆分<ul><li>IO瓶颈<ul><li>磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; <strong>分库和垂直分表</strong></li><li>网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; <strong>分库</strong></li></ul></li><li>CPU瓶颈<ul><li>SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; <strong>SQL优化</strong>，建立合适的索引，在业务Service层进行业务计算</li><li>单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&gt; <strong>水平分表</strong></li></ul></li></ul></li><li>选key很重要，既要考虑到拆分均匀，也要考虑到非partition key的查询</li><li>只要能满足需求，拆分规则越简单越好</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表&quot;&gt;&lt;/a&gt;为什么要分库分表&lt;/h3&gt;&lt;p&gt;当流量不大的时候，单机数据库就够了。后面因为业务的发展请求越来越多，但是我们发现大多数都是读请求，于是我们想到了将数据库的&lt;br&gt;&lt;strong&gt;写操作&lt;/strong&gt;和&lt;strong&gt;读操作&lt;/strong&gt;进行分离，使用多个从库（Slaver）副本负责读，使用主库（Master）负责写，主库的数据同步给从库保持数据的一致，从&lt;br&gt;库可以水平拓展，所以更多的读请求也不成问题&lt;/p&gt;
&lt;p&gt;但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保持一致性，写操作需要2个master&lt;br&gt;之间同步，相当于是重复了，而且更加复杂。这时就需要用到&lt;strong&gt;分库分表&lt;/strong&gt;，对写操作进行切分&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://xiebiao123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql" scheme="https://xiebiao123.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
